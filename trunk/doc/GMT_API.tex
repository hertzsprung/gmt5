%------------------------------------------
%       $Id$
%
%       The GMT Documentation Project
%       Copyright (c) 2000-2013.
%       P. Wessel, W. H. F. Smith, R. Scharroo, J. Luis and F. Wobbe
%------------------------------------------
%
\documentclass[11pt]{report}
\newcommand{\GMTTITLE}{C/C++ Application Programming Interface}
\input{GMT_macros}
\usepackage{arydshln}
\makeindex

%--------------------------------------------------------------------------
\begin{document}

\pagenumbering{roman}
\input{GMT_Cover}
\addcontentsline{toc}{chapter}{Front page}
\clearpage

\tableofcontents

\pagestyle{headings}

\chapter{Introduction}
\index{Introduction}
\pagenumbering{arabic}
\index{Purpose of the GMT API}
\index{GMT API!Purpose}

\section{Preamble}
\index{Preamble}

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm,bb=0 0 485 255]{GMT4_mode.png}
	\caption{GMT 4 programs contain all the high-level functionality.}
\end{figure}
Prior to version 5, the bulk of \GMT\ functionality was coded directly
in the standard \GMT\ C program modules (e.g., \filename{surface.c}, \filename{psxy.c}, \filename{grdimage.c}, etc.).
The \GMT\ library only offered access to low-level functions from which those
high-level \GMT\ programs were built.  The standard \GMT\ programs have been very successful,
with tens of thousands of users world-wide.  However, the design of the main programs
prevented developers from leveraging \GMT\ functionality from within other
programming environments since access to \GMT\ tools could only be achieved
via system calls\footnote{or via a very confusing and ever-changing myriad of
low-level library functions for bold programmers.}.
Consequently, all data i/o had to be done via temporary files.
The design also prevented the \GMT\ developers themselves from taking advantage of these
modules directly.  For instance, the tool \GMTprog{pslegend} needed to make extensive use of system calls
to \GMTprog{psxy} and \GMTprog{pstext} in order to plot the lines, symbols and text
that make up a map legend, making it a very awkward program to maintain.

\begin{figure}[h]
	\centering
	\includegraphics[width=10cm,bb=0 0 485 255]{GMT5_mode.png}
	\caption{GMT 4 programs contain all the high-level functionality.}
\end{figure}
Starting with \GMT\ version 5, all standard \GMT\ programs have been split into a short driver
program (the ``new'' \GMT\  programs) and a function ``module''.  The drivers simply call the corresponding \GMT\ modules;
it is these modules that do all the work.  These new functions have been placed
in a new \GMT\ high-level API library and can be called from a variety of environments
(C/C++, Fortran, Python, Matlab, Visual Basic, Julia, R, etc.)\footnote{Currently, only C/C++ and Matlab are being tested.}.
For example, the main program
\filename{blockmean.c} has been reconfigured as a high-level function \GMTfunc{GMT\_blockmean()},
which does the actual spatial averaging and can pass the result back to the calling program (or write it to file).
The previous behavior of \filename{blockmean.c} is replicated by a short driver program
that simply collects user arguments and then calls \GMTfunc{GMT\_blockmean()}.  Indeed, the driver
programs for all the standard \GMT\ programs are identical so that the makefile generates them
on-the-fly when it compiles and links them with the \GMT\ library into executables.
Thus, \filename{blockmean.c} and others do in fact no longer exist.

\section{The i/o abstraction layer}

In order for this interface to be as flexible as possible we have generalized the notion of input
and output. Data that already reside in an application's memory may serve as
input to a \GMT\ function.  Other sources of input may be file pointers
and file descriptors (as well as the already-supported mechanism for passing file names).
For standard data table i/o, the \GMT\ API takes care of the task of assembling any combination
of files, pointers, and memory locations into \emph{a single virtual data set} from which the \GMT\
function may read (a) all records at once into memory, or (b) read one record at a time.
Likewise, \GMT\ functions may write their output to a virtual destination, which
might be a memory location in the user's application, a file pointer or descriptor, or
an output file.  The \GMT\ functions are unaware of these details and simply
read from a ``source'' and write to a ``destination''.

\section{Our audience}

Here, we document the new functions in the \GMT\ API library for application developers
who wish to call these functions from their own custom programs.  At this point,
only the new high-level \GMT\ API is fully documented and intended for public use.
The structure and documentation of the under-lying lower-level \GMT\ library is not finalized.
Developers using these functions may risk disruption to their programs due to changes we may
make in the library in support of the \GMT\ API.  However, developers who wish to make supplemental
packages to be distributed as part of \GMT\ will (other than talk to us) probably want to access
the entire low-level \GMT\ library as well.  It is unlikely that library will every be fully
documented.

\section{Definitions}

For the purpose of this documentation a few definitions are needed:

\begin{enumerate}
\item ``Standard \GMT\ program'' refers to one of the traditional stand-alone command-line
executables known to all \GMT\ users, e.g., \GMTprog{blockmean}, \GMTprog{psxy},
\GMTprog{grdimage}, etc.  Prior to version 5, these were the only \GMT\ executables available.
\item ``\GMT\ module'' refers to the function in the \GMT\ API
library that is responsible for all the action taken by the corresponding \GMT\ program.  All
such modules are given the same name as the corresponding program but carry the
prefix \texttt{GMT\_}, e.g., \texttt{GMT\_blockmean}.
\item ``\GMT\ application'' refers to a new application written by any developer
and may call one or more \GMT\ functions to create a new \GMT-compatible executable.
\item In the API description that follows we will use the type \texttt{int} to mean
a 4-byte integer.  All integers used in the API are 4-byte integers with the exception
of one function where a longer integer is used.  Since different operating systems have their
own way of defining 8-byte integers we use C99's \texttt{int64\_t} for this purpose; it is guaranteed to yield
the correct type that the \GMT\ function expect.
\end{enumerate}
In version 5, the standard \GMT\ programs are themselves specific but overly simple examples
of \GMT\ applications that only call the single \GMT\ function they are associated with.
However, some programs such as \GMTprog{pslegend}, \GMTprog{gmtconvert}, \GMTprog{grdblend},
\GMTprog{grdfilter} and others call several modules.

\section{Recognized resources}
\index{Recognized resources}
\index{Resources!Recognized by GMT}

The \GMT\ API knows how to read and write five types of data common to \GMT\ operations:
CPT palette tables, data tables (ASCII or binary), text tables, \GMT\ grids and images (reading only).
In addition, we present two data types to facilitate the passing of simple user arrays (one or more equal-length data columns
of any data type, e.g., double, char) and 2-D or 3-D user matrices (of any data type and column/row
organization\footnote{At the moment, GMT does not have native support for 3-D grids.}). We
refer to these data types as \GMT\ \emph{resources}.
There are many attributes for each of these resources and therefore we use a top-level structure for each type
to keep them all in one container.  These containers are given or returned by the \GMT\ API
functions using opaque pointers (\texttt{void *}).  Below we discuss these containers in some detail; we
will later present how they are used when importing or exporting them to or from files,
memory locations, or streams.  The first five are the standard \GMT\ objects, while the latter two are the
special user data containers to facilitate converting user data into \GMT\ resources.

\subsection{Data tables}
\index{Data tables}
\index{Resources!Data tables}

Much data processed in \GMT\ come in the form of ASCII, netCDF, or native binary data tables.  These may
have any number of header records (ASCII files only) and perhaps segment headers.  \GMT\ programs will
read one or more such tables when importing data.  However, to avoid memory duplication or limitations
some programs may prefer to read
records one at the time.  The \GMT\ API has functions that let you read record-by-record
by presenting a virtual data set that combines all the data tables specified as input.
This simplifies record processing considerably.  A \texttt{struct GMT\_DATASET} may contain
any number of tables, each with any number of segments, each segment with any number of records,
and each record with any number of columns.   Thus, the
arguments to \GMT\ API functions that handle such data sets expect this type of variable.  All segments
are expected to have the same number of columns.

\subsection{Text tables}
\index{Text tables}
\index{Resources!Text tables}

Some data needed by \GMT\ are simply free-form ASCII text tables.  These are handled
similarly to data tables.  E.g., they may have any number of header records and even segment headers,
and \GMT\ programs can read one or more tables or get text records one at the time.
A \texttt{struct GMT\_TEXTSET} may contain
any number of tables, each with any number of segments, and each segment with any number of records.   Thus, the
arguments to \GMT\ API functions that handle such data sets expect this type of variable.  The user's
program may then parse and process such text records as required.  This resources is particularly useful
when your data consist of a mix or data coordinates and ordinary text since regular data tables will be
parsed for floating-point columns only.

\subsection{GMT grids}
\index{GMT grids}
\index{Resources!GMT grids}

\GMT\ grids are used to represent equidistant and organized 2-D surfaces.  These can be
plotted as contour maps, color images, or as perspective surfaces.  Because the native
\GMT\ grid is simply a 1-D float array with all the metadata kept in a separate header, we
pass this information via a \texttt{struct GMT\_GRID}, which is a container that holds both items.
Thus, the arguments to \GMT\ API functions that handle such \GMT\ grids expect this type
of variable.

\subsection{CPT palette tables}
\index{CPT palette tables}
\index{Resources!CPT palette tables}

The color palette table files, or just CPT tables, contain colors and patterns used for plotting
data such as surfaces (i.e., \GMT\ grids) or symbols, lines and polygons (i.e., \GMT\ tables).
\GMT\ programs will generally read in a CPT
palette table, make it the current palette, do the plotting, and destroy the table when done.
The information is referred to via a pointer to \texttt{struct GMT\_PALETTE}.  Thus, the
arguments to \GMT\ API functions that handle palettes expect this type of variable. It is not expected
that users will wish to manipulate a CPT table directly, but rather use this mechanism to hold them
in memory and pass as arguments to \GMT\ modules.

\subsection{GMT images}
\index{GMT images}
\index{Resources!GMT images}

\GMT\ images are used to represent bit-mapped images typically obtained via the GDAL bridge.  These can be
reprojected internally, such as when used in grdimage.  Since images and grids share the concept
of a header, we use the same header structure for grids as for images; however, some additional
metadata attributes are also needed.  Finally, the image itself may be of any data type and have more than one band (channel).
Both image and header information are passed via a \texttt{struct GMT\_IMAGE}, which is a container that holds both items.
Thus, the arguments to \GMT\ API functions that handle \GMT\ images expect this type
of variable.  Unlike the other objects, images can only be read and not written\footnote{This may change in later releases.}.

\subsection{User data columns (GMT vectors)}
\index{User data columns}
\index{GMT vectors}
\index{Resources!User data columns}

Programs that wish to call \GMT\ modules may hold data in their own particular data
structures.  For instance, the user's program may have three column arrays of type float
and wishes to use these as the input source to the \texttt{GMT\_surface} module, which normally
expects double precision triplets via a \texttt{struct GMT\_DATASET} read from a file or given by memory reference.
Simply create a new \texttt{struct GMT\_VECTOR} (see section~\ref{sec:create}) and assign the union
array pointers (see Table~\ref{tbl:univector}) to your data columns and provide
the required information on length, data types, and optionally range (see Table~\ref{tbl:vector}).
By letting the \GMT\ module know you are passing a data set \emph{via} a \texttt{struct GMT\_VECTOR} it
will know how to read the data correctly.

\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!union GMT_UNIVECTOR {! & \\
\verb!  uint8_t *uc1;!  & /* \emph{Pointer for unsigned 1-byte array} */ \\
\verb!  int8_t *sc1;!   & /* \emph{Pointer for signed 1-byte array} */ \\
\verb!  uint16_t *ui2;! & /* \emph{Pointer for unsigned 2-byte array} */ \\
\verb!  int16_t *si2;!  & /* \emph{Pointer for signed 2-byte array} */ \\
\verb!  uint32_t *ui4;! & /* \emph{Pointer for unsigned 4-byte array} */ \\
\verb!  int32_t *si4;!  & /* \emph{Pointer for signed 4-byte array} */ \\
\verb!  uint64_t *ui8;! & /* \emph{Pointer for unsigned 8-byte array} */ \\
\verb!  int64_t *si8;!  & /* \emph{Pointer for signed 8-byte array} */ \\
\verb!  float *f4;!     & /* \emph{Pointer for float array} */ \\
\verb!  double *f8;!    & /* \emph{Pointer for double array} */ \\
\verb!};!               & \\
\hline
\end{tabular}
\caption{Definition of the GMT\_UNIVECTOR union that holds a pointer to any array type.}
\label{tbl:univector}
\index{Vectors!Structure}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!struct GMT_VECTOR {!               & \\
\verb!  unsigned int n_columns;!         & /* \emph{Number of vectors} */\\
\verb!  uint64_t n_rows;!                & /* \emph{Number of rows in each vector} */ \\
\verb!  enum GMT_enum_type *type;!       & /* \emph{Array with data type for each vector} */\\
\verb!  double range[2];!                & /* \emph{The min and max limits on t-range (or 0,0) } */\\
\verb!  union GMT_UNIVECTOR *data;!      & /* \emph{Array with unions for each column} */\\ \hdashline
\verb!  unsigned int id;!                & /* \emph{An identification number} */ \\
\verb!  enum GMT_enum_alloc alloc_mode;! & /* \emph{Determines if we may free the vectors or not} */\\
\verb!};!                                & \\
\hline
\end{tabular}
\caption{Definition of the GMT\_VECTOR structure used to pass user data columns.  Items below the dashed
line are not meant to be accessed by developers.}
\label{tbl:vector}
\index{Vectors!Structure}
\end{table}
\noindent

\subsection{User data matrices (GMT matrices)}
\index{User data matrices}
\index{GMT matrices}
\index{Resources!User data matrices}

\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!struct GMT_MATRIX {!               & \\
\verb!  unsigned int n_rows;!            & /* \emph{Number of rows in the matrix} */ \\
\verb!  unsigned int n_columns;!         & /* \emph{Number of columns in the matrix} */\\
\verb!  unsigned int n_layers;!          & /* \emph{Number of layers in a 3-D matrix} */\\
\verb!  unsigned int shape;!             & /* \emph{0 = C (rows) and 1 = Fortran (cols)} */\\
\verb!  unsigned int registration;!      & /* \emph{0 for gridline and 1 for pixel registration} */\\
\verb!  size_t dim;!                     & /* \emph{Length of dimension for row (C) or column (Fortran)} */\\
\verb!  size_t size;!                    & /* \emph{Byte length of data} */\\
\verb!  enum GMT_enum_alloc alloc_mode;! & /* \emph{Determines if we may free the vectors or not} */\\
\verb!  double range[6];!                & /* \emph{The min and max limits on x-, y-, and z-ranges} */\\
\verb!  union GMT_UNIVECTOR data;!       & /* \emph{Union with pointers a data matrix of any type} */\\ \hdashline
\verb!  unsigned int id;!                & /* \emph{An identification number} */ \\
\verb!  enum GMT_enum_type type;!        & /* \emph{The matrix data type} */\\
\verb!};!                              & \\ \hline
\end{tabular}
\caption{Definition of the GMT\_MATRIX structure used to pass a user data matrix. Items below the dashed
line are not meant to be accessed by developers.}
\label{tbl:matrix}
\index{Matrix!Structure}
\end{table}
\noindent
Likewise, programs may have an integer 2-D matrix in memory 
and wish to use that as the input grid to the \texttt{GMT\_grdfilter} module, which normally
expects a \texttt{struct GMT\_GRID} with floating point data via a file or provided by memory reference.  As for user vectors, we create a
\texttt{struct GMT\_MATRIX} (see section~\ref{sec:create}), assign the appropriate union pointer to your data
matrix and provide information on dimensions and data type (see Table~\ref{tbl:matrix}).
Let the \GMT\ module know you are passing a grid via a
\texttt{struct GMT\_MATRIX} and it will know how to read the matrix properly.

The \texttt{enum} types referenced in Table~\ref{tbl:vector} and Table~\ref{tbl:matrix} and summarized in Table~\ref{tbl:enums}
and Table~\ref{tbl:types}.
\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_ALLOCATED		&      0	& Normal case; free item when done \\ \hline
GMT\_REFERENCE		&      1	& Item was \emph{not} allocated so do not free, but reallocate is ok \\ \hline
GMT\_READONLY		&      2	& Do not allocate or reallocate \\ \hline
GMT\_CLOBBER		&      3	& Free item no matter what its allocation status \\ \hline
\end{tabular}
\caption{Enumeration constants defined for decoding allocation modes.}
\label{tbl:enums}
\index{Resources!Parameters!Allocation constants}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_CHAR	&      0	& int8\_t, 1-byte signed integer type \\ \hline
GMT\_UCHAR	&      1	& int8\_t, 1-byte unsigned integer type \\ \hline
GMT\_SHORT	&      2	& int16\_t, 2-byte signed integer type \\ \hline
GMT\_USHORT	&      3	& uint16\_t, 2-byte unsigned integer type \\ \hline
GMT\_INT	&      4	& int32\_t, 4-byte signed integer type \\ \hline
GMT\_UINT	&      5	& uint32\_t, 4-byte unsigned integer type \\ \hline
GMT\_LONG	&      6	& int64\_t, 8-byte signed integer type \\ \hline
GMT\_ULONG	&      7	& uint64\_t, 8-byte unsigned integer type \\ \hline
GMT\_FLOAT	&      8	& 4-byte data float type \\ \hline
GMT\_DOUBLE	&      9	& 8-byte data float type \\ \hline
\end{tabular}
\caption{Enumeration constants defined for decoding data types.}
\label{tbl:types}
\index{Resources!Parameters!Data types}
\end{table}

\chapter{Overview of the GMT C Application Program Interface}
\index{Overview of interface}
\index{C Interface!Overview}
\label{ch:overview}

Users who wish to create their own \GMT\ application based on the API
must make sure their program goes through the steps below; details
for each step will be revealed in the following chapter.  We have kept the
API simple: In addition to the \GMT\ modules, there are only 20 public functions to become familiar with,
but most applications will only use a small subset of this selection.
Functions either return an integer error code (when things go wrong; otherwise it is set to GMT\_OK (0)),
or they return a void pointer to a \GMT\ resources (or NULL if things go wrong).  In either case
the API will report what the error is.
The layout here assumes you wish to use data in memory as input sources; if the data are simply
command-line files then things simplify considerably.

\begin{enumerate}
\item Initialize a new \GMT\ session with \texttt{GMT\_Create\_Session}, which
allocates a hidden \GMT\ API control structure and returns an opaque pointer to it.  This pointer is
the first argument to all subsequent \GMT\ API function calls within the session.
\item For each intended call to a \GMT\ module, several steps are involved:
\begin{enumerate}
\item Register input sources and output destination with \texttt{GMT\_Register\_IO}.
\item Each resource registration generates a unique ID number.  For memory resources, we embed these numbers
in unique filenames of the form ``@GMTAPI@-\#\#\#\#\#\#''.  When
\GMT\ i/o library functions encounter such filenames they extract the ID and make a connection
to the corresponding resource.  Multiple table data or text sources
are combined into a single virtual source for \GMT\ modules to operate on.
In contrast, CPT, Grid, and Image resources are operated on individually.
\item Enable data import once all registrations are complete.
\item Read data into memory. You may choose to read everything at once or read record-by-record (tables only).
\item Prepare required arguments and call the \GMT\ module you wish to use.
\item Process any results returned to memory via pointers rather than written to files.
\item Destroy the resources allocated by \GMT\ modules to hold results, or let the
garbage collector do this automatically at the end of the module and at the end of the session.
\end{enumerate}
\item Repeat steps a--f as many times as your application requires.
\item We terminate the GMT session by calling \texttt{GMT\_Destroy\_Session}.
\end{enumerate}

The steps a--d collapse into a single step if data are simply read from files.

Advanced programs may be calling more than one \GMT\ session and thus run several
sessions, perhaps concurrently as different threads on multi-core machines.
We will now discuss these steps in more detail.  Throughout, we will introduce upper-case \GMT\ C enum
constants \emph{in lieu} of simple integer constants.  These are considered part of the API
and are available for developers via the \filename{gmt.h} include file.

\chapter{The GMT C Application Program Interface}
\index{C interface}
\index{Interface!C}

\section{Initialize a new GMT\ session}
\index{Initialize a new GMT session}
\index{GMT session!Initialize}

Most applications will need to initialize only a single \GMT\ session.  This is true of all
the standard \GMT\ programs since they only call one \GMT\ module and then exit.  Most
user-developed \GMT\ applications are likely to only initialize one session even though
they may call many \GMT\ modules.  However, the \GMT\ API supports any number of
simultaneous sessions should the programmer wish to take advantage of it.  This
might be useful when you have access to several CPUs and want to spread the computing
load\footnote{However, there is no thread-support yet.}.  In the following discussion we
will simplify our treatment to the use of a single session only.

To initiate the new session we use

\index{GMT\_Create\_Session}
\begin{verbatim}
void * GMT_Create_Session (char *tag, unsigned int pad, unsigned int mode);
\end{verbatim}
and you will typically call it thus:
\begin{verbatim}
void *API = NULL;
API = GMT_Create_Session ("Session name", 2, 0);
\end{verbatim}
where \texttt{API} is an opaque pointer to the hidden \GMT\ API control structure.  You will need to
pass this pointer to \emph{all} subsequent \GMT\ API functions; this is how essential internal information
is passed from module to module.  The key task of this initialization
is to set up the \GMT\ machinery and its internal variables used for map projections, plotting, i/o,
etc.  The initialization also allocates space for internal structures used to register resources.
The \texttt{pad} argument sets how many rows and columns should be used for padding for grids and images
so that boundary conditions can be applied. \GMT\ uses 2 so we recommend that value. 
The \texttt{mode} argument is currently unused and reserved for future expansion. 
Should something go wrong then \texttt{API} will be returned as \texttt{NULL}.

\section{Register input or output resources}
\index{Register input or output resources}
\index{Resources!Register}
\index{Resources!Input}
\index{Resources!Output}
\index{Sources!Register Input}
\index{Sources!Register Output}

When using the standard \GMT\ programs, you specify input files on
the command line or via special program options (e.g., \Opt{I}\emph{intensity.nc}). The output of
the programs are either written to standard output (which you redirect to files or pipe to other programs)
or to files specified by specific program options (e.g., \Opt{G}\emph{output.nc}).  Alternatively, the
\GMT\ API allows you to specify input (and output) to be associated with open file handles
or program variables.  We will examine this more closely below.  Registering a
resource is a required step before attempting to import or export data that \emph{do not} come from files
or standard input/output.

\subsection{Resource registration}
Registration involves a direct or indirect call to
\index{GMT\_Register\_IO}

\begin{verbatim}
int GMT_Register_IO (void *API, unsigned int family, \
    unsigned int method, unsigned int geometry, \
    unsigned int direction, double wesn[], void *ptr);
\end{verbatim}
where \texttt{family} specifies what kind of resource is to be registered
(see Table \ref{tbl:family} for list of all families), \texttt{method} specifies
how we to access this resource (see Table \ref{tbl:methods} for recognized methods,
as well as modifiers you can add; these are listed in Table \ref{tbl:via}),
\texttt{geometry} specifies the geometry of the data (see Table \ref{tbl:geometry} for recognized geometries),
\texttt{ptr} is the address of the pointer to the named resource.  If \texttt{direction}
is GMT\_OUT and the \texttt{method} is not related to a file (filename, stream, or handle),
then \texttt{ptr} must be NULL.  After the \GMT\ module has written the data you can use
\texttt{GMT\_Retrieve\_Data} to assign a pointer to the memory location (variable) where the output was allocated.
For grid (and image) resources you may request to obtain a subset via the \texttt{wesn}
array (see Table~\ref{tbl:wesn} for information); otherwise, pass NULL to obtain the entire grid (or image).
The \texttt{direction} indicates input or output and is either GMT\_IN (0) or GMT\_OUT (1).
Finally, the function returns a unique resource ID, or GMTAPI\_NOTSET (-1) if there was an
error.

\subsection{Object ID encoding}
To use registered resources as program input or output arguments you must pass them via
a text string that acts as a special file name (Chapter~\ref{ch:overview}).  The proper filename
formatting is guaranteed by using the function
\index{GMT\_Encode\_ID}

\begin{verbatim}
int GMT_Encode_ID (void *API, char *filename, int ID);
\end{verbatim}
which accepts the unique \texttt{ID} and writes the corresponding \texttt{filename}.
The variable \texttt{filename} must have enough space to hold 16 bytes.
The function returns TRUE (1) if there is an error; otherwise it returns FALSE (0).

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{family}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{source points to}} \\ \hline
GMT\_IS\_DATASET	&	0	&	A [multi-segment] table file \\ \hline
GMT\_IS\_TEXTSET	&	1	&	A [multi-segment] text file \\ \hline
GMT\_IS\_GRID		&	2	&	A \GMT\ grid file \\ \hline
GMT\_IS\_CPT		&	3	&	A CPT file \\ \hline
GMT\_IS\_IMAGE		&	4	&	A \GMT\ image \\ \hline
\end{tabular}
\caption{API constants for specifying input or output data families.}
\label{tbl:family}
\index{Resources!Parameters!Floating point}
\end{table}


\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{method}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{how to read/write data}} \\ \hline
GMT\_IS\_FILE		&	0	&       Pointer to name of a file \\ \hline
GMT\_IS\_STREAM		&	1	&       Pointer to open stream (or process)  \\ \hline
GMT\_IS\_FDESC		&	2	&       Pointer to integer file descriptor \\ \hline
GMT\_IS\_DUPLICATE	&	3	&       Pointer to memory we may \emph{duplicate} data from \\ \hline
GMT\_IS\_REFERENCE	&	4	&       Pointer to memory we may \emph{reference} data from (realloc OK) \\ \hline
GMT\_IS\_READONLY	&	5	&       Pointer to memory we may \emph{read} data from (no realloc) \\ \hline
\end{tabular}
\caption{API constants used when specifying input or output methods.}
\label{tbl:methods}
\index{Resources!Methods}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{approach}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{how method is modified}} \\ \hline
GMT\_VIA\_VECTOR	&	100	&       User's data columns are accessed via a GMT\_VECTOR structure \\ \hline
GMT\_VIA\_MATRIX	&	200	&       User's matrix is accessed via a GMT\_MATRIX structure \\ \hline
\end{tabular}
\caption{API constants used when user data forms are involved.  These are added
to the \emph{method} value used when registering the resource.}
\label{tbl:via}
\index{Resources!Conversions}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{geometry}} & \multicolumn{1}{c|}{\emph{value}} & \multicolumn{1}{c|}{\emph{description}} \\ \hline
GMT\_IS\_TEXT		&	0	&       Not a geographic item \\ \hline
GMT\_IS\_POINT		&	1	&       Multi-dimensional point data \\ \hline
GMT\_IS\_LINE		&	2	&       Geographic or Cartesian line segments \\ \hline
GMT\_IS\_POLYGON	&	3	&       Geographic or Cartesian closed polygons \\ \hline
GMT\_IS\_SURFACE	&	4	&       2-D gridded surface \\ \hline
\end{tabular}
\caption{API constants defined to register different geometries.}
\label{tbl:geometry}
\index{Resources!Geometries}
\end{table}

\begin{table}[h]
\small
\centering
\begin{tabular}{|c|l|l|} \hline
\multicolumn{2}{|c|}{\emph{Index}} & \multicolumn{1}{c|}{\emph{content}} \\ \hline
0 & GMT\_XLO	&       x\_min (west) boundary of grid subset  \\ \hline
1 & GMT\_XHI	&       x\_max (east) boundary of grid subset  \\ \hline
2 & GMT\_YLO	&       y\_min (south) boundary of grid subset  \\ \hline
3 & GMT\_YHI	&       y\_max (north) boundary of grid subset  \\ \hline
4 & GMT\_ZLO	&       z\_min (bottom) boundary of 3-D matrix subset  \\ \hline
5 & GMT\_ZHI	&       z\_max (top) boundary of 3-D matrix subset  \\ \hline
\end{tabular}
\caption{Domain boundaries (\texttt{wesn}) used when selecting subsets of grids.  The indices for
the 3rd dimension can be used with GMT\_MATRIX resources.}
\label{tbl:wesn}
\index{Resources!Parameters!Domain}
\end{table}

\subsection{Resource initialization}
\index{Resources!Initialization}
\index{Initialization!Resources}
All \GMT\ programs dealing with input or output files given on the command line, and perhaps defaulting to
the standard input or output streams if no files are given, must call the i/o initializer function
\texttt{GMT\_Init\_IO} once for each direction required (i.e., input and output separately).
For input it determines how many input sources have already been registered.
If none has been registered then it scans the program arguments for any filenames given on the command line and register
these input resources.  Finally, if we still have found no input sources we assign the standard input stream
as the single input source.  For output it is similar: If no single destination has been registered we specify the standard output stream
as the output destination.  Only one main output destination is allowed to be active when a module writes data (some
modules also write additional output via program-specific options).
The prototype for this function is
\index{GMT\_Init\_IO}

\begin{verbatim}
int GMT_Init_IO (void *API, unsigned int family, unsigned int geometry, \
    unsigned int direction, unsigned int mode, unsigned int n_args, \
    void *args);
\end{verbatim}
where \texttt{family} specifies what kind of resource is to be registered,
\texttt{geometry} specifies the geometry of the data,
\texttt{direction} is either \texttt{GMT\_IN} or \texttt{GMT\_OUT}, and
\texttt{mode} is a bit flag that determines what we do if no resources have been
registered. The choices are
\begin{description}
	\item [1] (or GMT\_ADD\_FILES\_IF\_NONE) means ``add command line (option) files if none have been registered already''
	\item [2] (or GMT\_ADD\_FILES\_ALWAYS) means ``always add any command line files''
	\item [4] (or GMT\_ADD\_STDIO\_IF\_NONE) means ``add std* if no other input/output have been specified''
	\item [8] (or GMT\_ADD\_STDIO\_ALWAYS) means ``always add std* even if resources have been registered''.
\end{description}
\index{GMT\_ADD\_FILES\_IF\_NONE}
\index{GMT\_ADD\_FILES\_ALWAYS}
\index{GMT\_ADD\_STDIO\_IF\_NONE}
\index{GMT\_ADD\_STDIO\_ALWAYS}
\index{GMT\_REG\_DEFAULT}
The standard behavior is 5 (or GMT\_REG\_DEFAULT).
Next, \texttt{n\_args} is 0 if \texttt{args} is the head of a linked list of options (further discussed in Section~\ref{sec:func});
otherwise \texttt{args} is an array of \texttt{n\_args} strings (i.e., the int argc, char *argv[] model)

Many programs will register an export location where results of a \GMT\ function (say,
a filtered grid) should be returned, but may then wish to use that variable as an \emph{input}
resource in a subsequent module call.  This is accomplished by re-registering the resource
as an \emph{input} source, thereby changing the \emph{direction} of the data set.
The function returns TRUE (1) if there is an error; otherwise it returns FALSE (0).

\subsection{Dimension parameters for user 1-D column vectors}
We refer to Table~\ref{tbl:vector}.  The \texttt{type} array must hold the
data type of each data column in the user's program.  All types other than GMT\_DOUBLE will
be converted internally in \GMT\ to \texttt{double}, thus possibly increasing memory requirements.
If the type is GMT\_DOUBLE then \GMT\ will be able to use the column directly by reference.  The \texttt{n\_columns}
and \texttt{n\_rows} parameters indicate the number of vectors and their common length.  If these
are not yet known you may pass 0 for these values
and set \texttt{alloc\_mode} to GMT\_REFERENCE (1); this will make
sure \GMT\ will allocate the necessary memory to the variable you specify.

\subsection{Dimension parameters for user 2-D table arrays}

We refer to Table~\ref{tbl:matrix}.  The \texttt{type} parameter specifies the
data type used for the array in the user's program.  All types other than GMT\_FLOAT will
be converted internally in \GMT\ to \texttt{float}, thus possibly increasing memory requirements.
If the type is GMT\_FLOAT then \GMT\ may be able to use the matrix directly by reference.  The \texttt{n\_rows}
and \texttt{n\_columns} parameters indicate the dimensions of the matrix.  If these
are not yet known you may pass 0 for these values and set \texttt{alloc\_mode} to GMT\_REFERENCE 1; this will make
sure \GMT\ will allocate the necessary memory at the location you specify.  Fortran users
will instead have to specify a size large enough to hold the anticipated output data.
The \texttt{registration} and \texttt{range} gives the grid registration and domain.
Finally, use \texttt{dim} to indicate if the memory matrix has a dimension that
exceeds that of the leading row (or column) dimension. Note: For GMT\_IS\_TEXTSET
the user matrix is expected to be a 2-D character array with a fixed row length of \texttt{dim}
but we only consider the first \texttt{n\_columns} characters.  For data grids you will
also need to specify the \texttt{registration}  (see the \GMT\ Cookbook and Reference,
Appendix B for description of the two forms of registration) and data domain \texttt{range}.

\section{Create empty resources}
\index{Create empty resources}
\index{Resources!Create}
\label{sec:create}

If your application needs to build and populate \GMT\ resources in ways that do
not depend on external resources (files, memory locations, etc.), then you
can obtain a ``blank slate'' by calling

\begin{verbatim}
void * GMT_Create_Data (void *API, unsigned int family, unsigned int geometry, \
    unsigned int mode, uint64_t par[], double *wesn, double *inc, \
    unsigned int registration, int pad, void *data
\end{verbatim}
\index{GMT\_Create\_Data}
which returns a pointer to the allocated resource.
Pass \texttt{family} as one of GMT\_IS\_GRID, GMT\_IS\_IMAGE, GMT\_IS\_DATASET, GMT\_IS\_TEXTSET, or GMT\_IS\_CPT,
or via the modifiers GMT\_IS\_VECTOR or GMT\_IS\_MATRIX when handling user data.  Also pass
a compatible \texttt{geometry}.
Depending on the family and your particular way of representing dimensions you may pass
the additional parameters in one of two ways:
\begin{enumerate}
	\item Actual integer dimensions of items needed.
	\item Physical distances and increments of each dimension.
\end{enumerate}

For method (1), pass the \texttt{par} array, as indicated below:
\begin{description}
	\item [GMT\_IS\_GRID]: An empty GMT\_GRID structure with a header is
	allocated; the data array is NULL.  The \texttt{par} argument is not used.
	\item [GMT\_IS\_IMAGE]: An empty GMT\_GRID structure with a header is
	allocated; the image array is NULL.  The \texttt{par} argument is not used.
	\item [GMT\_IS\_DATASET]: An empty GMT\_DATASET structure consisting of
	\texttt{par[0]} tables, each with \texttt{par[1]} segments, each with
	\texttt{par[2]} columns, all with \texttt{par[3]} rows, is allocated.
	\item [GMT\_IS\_TEXTSET]: An empty GMT\_TEXTSET structure consisting of
	\texttt{par[0]} tables, each with \texttt{par[1]} segments,
	all with \texttt{par[2]} text record, is allocated.
	\item [GMT\_IS\_CPT]: An empty GMT\_PALETTE structure with \texttt{par[0]}
	palette entries is allocated.
	\item [GMT\_IS\_VECTOR]: An empty GMT\_VECTOR structure with \texttt{par[0]}
	column entries is allocated.
	\item [GMT\_IS\_MATRIX]: An empty GMT\_MATRIX structure is allocated.
	\texttt{par[0]} indicates the number of layers for a 3-D matrix, or pass 0, 1, or
	NULL for a 2-D matrix.
	
\end{description}
In this case, pass \texttt{wesn}, \texttt{inc} as NULL.
For method (2), you instead pass \texttt{wesn}, \texttt{inc}, and \texttt{registration}
and leave \textt{par} as NULL.  For grids and images you may
pass \texttt{pad} to set the padding, or -1 to accept the \GMT\ default.
The \texttt{mode} determines what is actually allocated when you have chosen grids or
images.  As for \texttt{GMT\_Read\_Data} you can pass \texttt{GMT\_GRID\_ALL} to
initialize the header and allocate space for the array.  Alternatively, you can
pass \texttt{GMT\_GRID\_HEADER\_ONLY} to just initialize the grid or image header, and
call \textt{GMT\_Create\_Data} a second time, passing \texttt{GMT\_GRID\_DATA\_ONLY}, to allocate space for the array.
In that second call you pass the pointer returned by the first call as \texttt{data}
and specify the family; all other arguments should be NULL or 0.
The function returns a pointer to the data container. In case of an error we return a
NULL pointer and pass an error code via \texttt{API->error}.
\index{GMT\_GRID\_ALL}
\index{GMT\_GRID\_HEADER\_ONLY}
\index{GMT\_GRID\_DATA\_ONLY}

\section{Duplicate resources}
\index{Duplicate resources}
\index{Resources!Duplicate}
\label{sec:duplicate}
\index{Duplicate!Data}
\index{Data!Duplicate}

Often you have read or created a data resource and then need an identical copy, presumably
to make modifications to.  Or, you want a copy with the same dimensions and allocated memory,
except data values should not be duplicated. Alternatively, perhaps you just want to duplicate
the header and skip the allocation and duplication of the data.  These tasks are addressed by

\begin{verbatim}
void * GMT_Duplicate_Data (void *API, unsigned int family, \
    unsigned int mode, void *data);
\end{verbatim}
\index{GMT\_Duplicate\_Data}
which returns a pointer to the allocated resource.  Specify which \texttt{family} and
select \texttt{mode} from \texttt{GMT\_DUPLICATE\_DATA}, \texttt{GMT\_DUPLICATE\_ALLOC},
and \texttt{GMT\_DUPLICATE\_NONE}, as discussed above.  The \texttt{data} is a pointer
to the resource you wish to duplicate.  In case of an error we return a
NULL pointer and pass an error code via \texttt{API->error}.
\index{GMT\_DUPLICATE\_DATA}
\index{GMT\_DUPLICATE\_ALLOC}
\index{GMT\_DUPLICATE\_NONE}

\section{Import Data}
\index{Import!Data}
\index{Data!Import}
\index{Resources!Import data}

If your main program needs to read any of the five recognized data types (CPT files, data tables, text tables, \GMT\ grids, or images)
you will use the \texttt{GMT\_Get\_Data} or \texttt{GMT\_Read\_Data} functions, which both return entire data sets.
In the case of data and text tables you may also select record-by-record reading using the \texttt{GMT\_Get\_Record} function.
As a general rule, your program development simplifies if you can read entire resources into memory with
\texttt{GMT\_Get\_Data} or \texttt{GMT\_Read\_Data}.  However, if this leads to unacceptable memory usage or if the program logic is particularly simple,
you may obtain one data record at the time via \texttt{GMT\_Get\_Record}.

All input functions takes a parameter called \texttt{mode}.  The \texttt{mode} parameter generally
has different meanings for the different data types and will be discussed below.
However, one bit setting is common to all types: By default, you are only allowed to read a
data source once; the source is then flagged as having been read and subsequent attempts to read
from the same source will result in a warning and no reading takes place.  In the unlikely event you need to re-read a
source you can override this default behavior by adding GMT\_IO\_RESET to your \texttt{mode} parameter.
Note that this override does not apply to sources that are streams or file handles, as it may not be
possible to re-read their contents.

\subsection{Enable Data Import}
\index{Import!Enable}
\index{Data!Import}
\index{Resources!Import data}

Once all input resources have been registered, we signal the API that we are done with the registration
phase and are ready to start the actual data import.  This step is only required when reading one record at the
time.  We initialize record-by-record reading by calling \texttt{GMT\_Begin\_IO}.  This function enables dataset
and textset record-by-record reading and prepares the registered sources for the upcoming import.
The prototype is

\begin{verbatim}
int GMT_Begin_IO (void *API, unsigned int family, unsigned int direction, \
    unsigned int mode, unsigned int header);
\end{verbatim}
where \texttt{family} specifies the resource type to be read or written (see Table \ref{tbl:family};
only GMT\_IS\_DATASET and GMT\_IS\_TEXTSET are available for record-by-record handling).
The \texttt{direction} is either GMT\_IN or GMT\_out, so for import we obviously use GMT\_IN.
The function determines the first input source and sets up procedures for skipping to the next input source in a virtual data set.
The \texttt{GMT\_Get\_Record} function will not be able to read any data before \texttt{GMT\_Begin\_IO} has been called.  As you might
guess, there is a companion \texttt{GMT\_End\_IO} function that completes, then disables record-by-record data access.  You can use these several
times to switch modes between registering data resources, doing the importing/exporting, and disabling further
data access, perhaps to do more registration.  We will discuss \texttt{GMT\_End\_IO} once we are done with the data import.
The \texttt{mode} option is used to allow output to write table header information (\texttt{GMT\_HEADER\_ON}) or not (\texttt{GMT\_HEADER\_OFF}).
This is usually on unless you are writing messages and other non-data.
The final \texttt{header} argument determines if the common header-block should be written during initialization; choose
between \texttt{GMT\_HEADER\_ON} (1) and \texttt{GMT\_HEADER\_OFF} (0).
The function returns TRUE (1) if there is an error; otherwise it returns FALSE (0).

\subsection{Import a data set}
\index{Import!Data set}
\index{Data!Import data}
\index{Resources!Import data set}

If your program needs to import any of the five recognized data types (CPT table, data table, text table, \GMT\ grid, or image)
you will use either the \texttt{GMT\_Read\_Data} or \texttt{GMT\_Get\_Data} functions.  The former is typically used when
reading from files, streams (e.g., \texttt{stdin}), or an open file handle, while the latter is only used with a registered
resource via its unique ID.  Because of the similarities of these five import functions we use an generic form that covers all of them.

\subsubsection{Import from a file, stream, or handle}
\index{GMT\_Read\_Data}
To read an entire resource from a file, stream, or file handle, use
\begin{verbatim}
void * GMT_Read_Data (void *API, unsigned int family, \
    unsigned int method, unsigned int geometry, unsigned int mode, \
    double wesn[], char *input, void *ptr);
\end{verbatim}
where \texttt{ptr} is NULL except when reading grids in two steps
(i.e., first get a grid structure with a header, then read the data).
Most of these arguments have been discussed earlier.  This function can
be called in three different situations:
\begin{enumerate}
\item If you have a single source (filename, stream pointer, etc.) you can call
\texttt{GMT\_Read\_Data} directly; there is no need to first register the source
with \texttt{GMT\_Register\_IO} or gather the sources with \texttt{GMT\_Init\_IO}.
However, if you did register a single source you can still pass it via an encoded
filename (see \texttt{GMT\_Encode\_ID}) or you can instead use \texttt{GMT\_Get\_Data}
using the integer ID directly (see next section).
\item If you want to specify \texttt{stdin} as source then use \texttt{input} as NULL.
\item If you already registered all desired sources with \texttt{GMT\_Init\_IO} then
you indicate this by passing \texttt{geometry} = 0.
\end{enumerate}
Space will be allocated to hold the results, if needed, and a pointer to the object is returned.
If there are errors we simply return NULL and report the error.
The \texttt{mode} parameter has different meanings for different data types.
\begin{description}
\item [CPT table]:  \texttt{mode} contains bit-flags that control how the CPT file's back-, fore-, and NaN-colors
should be initialized.  Select 0 to use the CPT file's back-, fore-, and NaN-colors, 2
to replace these with the \GMT\ default values, or 4 to replace them with the color table's
entries for highest and lowest value.
\item [Data table]:  \texttt{mode} is currently not used.
\item [Text table]:  \texttt{mode} is currently not used.
\item [GMT grid]:  Here, \texttt{mode} determines how we read the grid:
\index{GMT\_GRID\_ALL}
\index{GMT\_GRID\_HEADER\_ONLY}
\index{GMT\_GRID\_DATA\_ONLY}
\index{GMT\_GRID\_IS\_COMPLEX\_REAL}
\index{GMT\_GRID\_IS\_COMPLEX\_IMAG}
\index{GMT\_GRID\_ROW\_BY\_ROW}
\index{GMT\_GRID\_ROW\_BY\_ROW\_MANUAL}
To read the entire grid and its header, pass GMT\_GRID\_ALL.  However, if you
need to extract a sub-region you must first read the header by passing
GMT\_GRID\_HEADER\_ONLY, then examine the header structure range attributes and
to specify a subset via the array \texttt{wesn}, and finally call
\texttt{GMT\_Read\_Data} a second time, now with \texttt{mode} = GMT\_GRID\_DATA\_ONLY and passing your \texttt{wesn} array
and the grid structure returned from the first call as \texttt{ptr}.
In the event your data array should be allocated to hold both the real and imaginary parts of a
complex data set you must add either GMT\_GRID\_IS\_COMPLEX\_REAL or GMT\_GRID\_IS\_COMPLEX\_IMAG to \texttt{mode}
so as to allow for the extra memory needed and to stride the input values correctly.
If your grid is huge and you must read it row-by-row, set \texttt{mode} to
GMT\_GRID\_HEADER\_ONLY | GMT\_GRID\_ROW\_BY\_ROW.  You can then access the grid row-by-row
using \texttt{GMT\_Get\_Row}.  By default the rows will be automatically
processed in order.  To completely specify which row to be read, use GMT\_GRID\_ROW\_BY\_ROW\_MANUAL
instead.
\end{description}

\subsubsection{Import from a memory location}

If you are importing via variables or prefer to first register the source, then you
should use \texttt{GMT\_Get\_Data} instead.  This function requires fewer arguments since you simply
pass the unique ID number of the resource.  The function is described as follows:

\index{GMT\_Get\_Data}

\begin{verbatim}
void * GMT_Get_Data (void *API, int ID, unsigned int mode, void *ptr);
\end{verbatim}
The \texttt{ID} is the unique object ID you received when registering the resource,
\texttt{mode} controls some aspects of the import (see \texttt{GMT\_Read\_Data} above),
while \texttt{ptr} is NULL except when reading grids in two steps
(i.e., first get a grid structure with a header, then read the data).
Other arguments have been discussed earlier.  
Space will be allocated to hold the results, if needed, and a pointer to the object is returned.
If there are errors we simply return NULL and report the error.

\subsubsection{Retrieve an allocated result}

Finally, if you need to access the result that a GMT\ module wrote to a memory location,
then you must register an output destination with \texttt{GMT\_Register\_IO} first (passing \texttt{ptr} == NULL).
The GMT\ module will then allocate space to hold the output and let the API know where this memory resides.
You can then use \texttt{GMT\_Retrieve\_Data} to get a pointer to the container where the data set was stored.
This function requires fewer arguments since you simply
pass the unique ID number of the resource.  The function is described as follows:

\index{GMT\_Retrieve\_Data}

\begin{verbatim}
void * GMT_Retrieve_Data (void *API, int ID);
\end{verbatim}
The \texttt{ID} is the unique object ID you received when registering the NULL resource earlier,
Since this container has already been created, a pointer to the object is returned.
If there are errors we simply return NULL and report the error.

\subsection{Importing a data record}
\index{Importing a data record}
\index{Data!Import data record}
\index{Resources!Import data record}

If your program will read data table records one-by-one you must first
enable this input mechanism with \texttt{GMT\_Begin\_IO} and then read
the records in a loop using
\index{GMT\_Get\_Record}

\begin{verbatim}
void * GMT_Get_Record (void *API, unsigned int mode, int *nfields);
\end{verbatim}
where the returned value is either a pointer to a double array with the current row values
or to a character string with the current row, depending on \texttt{mode}.
In either case these pointers point to memory internal to \GMT\ and should be considered read-only.
When we reach end-of-file, encounter conversion problems, read header comments, or identify
segment headers we return a NULL pointer.
The \texttt{nfields} pointer will return the number of fields returned; pass NULL if your program
should ignore this information.

Normally (\texttt{mode} == GMT\_READ\_DOUBLE or 0), we return a pointer to the double array.
\index{GMT\_READ\_DOUBLE}
\index{GMT\_READ\_TEXT}
To read text records, supply instead \texttt{mode} == GMT\_READ\_TEXT (or 1) and we
instead return a pointer to the text record.
However, if you have input records that mixes organized floating-point columns with text
items you could pass \texttt{mode} == GMT\_READ\_MIXED (2).  Then, \GMT\ will attempt to extract the
floating-point values; you can still access the record string, as discussed below.
Finally, if your application needs to be notified when \GMT\ closes one file and opens the next,
add GMT\_FILE\_BREAK to \texttt{mode} and check for the status code GMT\_IO\_NEXT\_FILE (by
default, we treat the concatenation of many input files as a single virtual file).
Using \texttt{GMT\_Get\_Record} requires you to first initialize the source(s)
with \texttt{GMT\_Init\_IO}.
For certain records, \texttt{GMT\_Get\_Record} will return NULL and sets status codes that your
program will need to examine to take appropriate response.  Table~\ref{tbl:iostatus}
list the various status codes you can check for, using \texttt{GMT\_Status\_IO} (see next section).

\subsection{Examining record status}
\index{Examining record status}
\index{Data!Record status}
\index{Resources!Examining record status}

Programs that read record-by-record must be aware of what the current record represents.
Given the presence of headers, data gaps, NaN-record, etc. the developer will want to
check the status after reading the next record.  The internal i/o status mode can be
interrogated with the function

\begin{verbatim}
int GMT_Status_IO (void *API, unsigned int mode);
\end{verbatim}

which returns 0 (false) or 1 (true) if the current status is reflected by the specified \texttt{mode}.
There are 11 different modes available to programmers; for a list see Table~\ref{tbl:iostatus}.
For an example of how these may be used, see the test program \filename{testgmtio.c}.
Developers who plan to import data on a record-by-record basis may also consult the source
code of, say, \filename{blockmean.c} or \filename{pstext.c}, to see examples of working code.

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|} \hline
\multicolumn{1}{|c|}{\emph{mode}} & \multicolumn{1}{c|}{\emph{description}} \\ \hline
\texttt{GMT\_IO\_DATA\_RECORD}	&       1 if we read a data record \\ \hline
\texttt{GMT\_IO\_TABLE\_HEADER}	&       1 if we read a table header \\ \hline
\texttt{GMT\_IO\_SEGMENT\_HEADER}	&       1 if we read a segment header \\ \hline
\texttt{GMT\_IO\_ANY\_HEADER}	&       1 if we read either header record \\ \hline
\texttt{GMT\_IO\_MISMATCH}	&       1 if we read incorrect number of columns \\ \hline
\texttt{GMT\_IO\_EOF}		&       1 if we reached the end of the file (EOF) \\ \hline
\texttt{GMT\_IO\_NAN}		&       1 if we only read NaNs \\ \hline
\texttt{GMT\_IO\_GAP}		&       1 if this record implies a data gap \\ \hline
\texttt{GMT\_IO\_NEW\_SEGMENT}	&       1 if we enter a new segment \\ \hline
\texttt{GMT\_IO\_LINE\_BREAK}	&       1 if we encountered a segment header, EOF, NaNs or gap \\ \hline
\texttt{GMT\_IO\_NEXT\_FILE}	&       1 if we finished one file but not the last \\ \hline
\end{tabular}
\caption{Modes used to determine status of current data record.  The \texttt{GMT\_IO\_GAP} mode depends
on the current \Opt{g} settings.  The function returns false (0) unless the status is true (1).}
\label{tbl:iostatus}
\index{Record!Status}
\end{table}
\index{GMT\_IO\_DATA\_RECORD}
\index{GMT\_IO\_TABLE\_HEADER}
\index{GMT\_IO\_SEGMENT\_HEADER}
\index{GMT\_IO\_ANY\_HEADER}
\index{GMT\_IO\_MISMATCH}
\index{GMT\_IO\_EOF}
\index{GMT\_IO\_NAN}
\index{GMT\_IO\_GAP}
\index{GMT\_IO\_NEW\_SEGMENT}
\index{GMT\_IO\_LINE\_BREAK}
\index{GMT\_IO\_NEXT\_FILE}

\subsection{Importing a grid row}
\index{Importing a grid row}
\index{Data!Import grid row}
\index{Resources!Import grid row}

If your program must read a grid file row-by-row you must first enable row-by-row
reading with \texttt{GMT\_Read\_Data} and then use the \texttt{GMT\_Get\_Row} function in a loop;
the prototype is
\index{GMT\_Get\_Row}

\begin{verbatim}
int GMT_Get_Row (void *API, int row_no, struct GMT_GRID *G, float *row);
\end{verbatim}
where \texttt{row} is a pointer to a single-precision array to receive the current row,
\texttt{G} is the grid in question, and \texttt{row\_no} is the number of the current
row to be read.  Note this value is only considered if the row-by-row mode was
initialized with GMT\_GRID\_ROW\_BY\_ROW\_MANUAL.  The user must allocate enough
space to hold the entire row in memory. 

\subsection{Disable Data Import}
\index{Import!Disable}
\index{Data!Import}
\index{Resources!Import data}

Once the record-by-record input processing has completed we disable further input to prevent accidental
reading from occurring (due to poor program structure, bugs, etc.).  We do so by calling \texttt{GMT\_End\_IO}.  This
function disables further record-by-record data import; its prototype is

\begin{verbatim}
int GMT_End_IO (void *API, unsigned int direction, unsigned int mode);
\end{verbatim}

\noindent
and we specify \texttt{direction} = GMT\_IN.  At the moment, \texttt{mode} is not used.  This call
will also reallocate any arrays obtained into their proper lengths.
The function returns TRUE (1) if there is an error (which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

\section{Manipulate data}
\index{Data!Manipulate}
\label{sec:manipulate}

Once you have created and allocated and empty resources, or read in resources from the outside, you
will wish to manipulate their contents.  This section discusses how to set up loops and access
the important variables for the various data families.

\subsection{Manipulate grids}
\index{Grids!Manipulate}

Most applications wishing to manipulate grids will want to loop over all the nodes, typically
in a manner organized by rows and columns.  In doing so, the coordinates at each node may also
be required for a calculation.  Below is a snippet of code that shows how to do
visit all nodes in a grid and assign each node the product x * y:

\begin{verbatim}
int row, col, node;
double *x_coord = NULL, *y_coord = NULL;
< ... create a grid G or read one ... >
x_coord = GMT_Get_Coord (API, GMT_IS_GRID, GMT_X, G);
y_coord = GMT_Get_Coord (API, GMT_IS_GRID, GMT_Y, G);
for (row = 0; row < G->header->ny) {
    for (col = 0; col < G->header->nx; col++) {
        node = GMT_Get_Index (G->header, row, col);
        G->data[node] = x_coord[col] * y_coord[row];
    }
}
\end{verbatim}

Note the use of \texttt{GMT\_Get\_Index} to get the grid node number associated
with the \texttt{row} and \texttt{col} we are visiting.  Because \GMT\ grids have
padding (for boundary conditions) the relationship between rows, columns, and
node indices is more complicated and hence we hide that complexity in \texttt{GMT\_Get\_Index}.
Note that for trivial procedures such setting all grid nodes to a constant (e.g., -9999.0)
where the row and column does not enter you can instead do a single loop:

\begin{verbatim}
int node;
< ... create a grid G or read one ... >
for (node = 0; node < G->header->size) G->data[node] = -9999.0;
\end{verbatim}

Note we must use \texttt{G->header->size} (size of allocated array) and not
\texttt{G->header->size} (number of nodes in grid) since the latter is smaller
due to the padding and a single loop like the above treats the pad as part of
the ``inside'' grid.

\subsection{Manipulate data tables}
\index{Data tables!Manipulate}

Another common application is to process the records in a data table.
Because \GMT\ consider the GMT\_DATASET resources to contain one or
more tables, each of which may contain one or more segments, all of
which may contain one or more columns, you will need to have multiple
loops to visit all entries.  The following code snippet will visit
all data records and add 1 to all columns beyond the first two (x and y):

\begin{verbatim}
int tbl, seg, row, col;
struct GMT_DATATABLE *T = NULL;
struct GMT_DATASEGMENT *S = NULL;

< ... create a dataset D or read one ... >
for (tbl = 0; tbl < D->n_tables; tbl++) {	/* For each table */
  T = D->table[tbl];       /* Convenient shorthand for current table */
  for (seg = 0; seg < T->n_segments; seg++) {	/* For all segments */
    S = T->segment[seg];   /* Convenient shorthand for current segment */
    for (row = 0; row < S->n_rows; row++) {
      for (col = 2; col < T->n_columns; col++) {
        S->coord[col][row] += 1.0;
      }
    }
  }
}
\end{verbatim}

\subsection{Manipulate text tables}
\index{Text tables!Manipulate}

When data file contain text mixed in with numbers you must open the
file as a GMT\_TEXTSET and do your own parsing of the data records.
The following code snippet will visit all text records and print
them out:

\begin{verbatim}
int tbl, seg, row, col;
struct GMT_TEXTTABLE *T = NULL;
struct GMT_TEXTSEGMENT *S = NULL;

< ... create a textset D or read one ... >
for (tbl = 0; tbl < D->n_tables; tbl++) {	/* For each table */
  T = D->table[tbl];        /* Convenient shorthand for current table */
  for (seg = 0; seg < T->n_segments; seg++) {	/* For all segments */
    S = T->segment[seg];    /* Convenient shorthand for current segment */
    for (row = 0; row < S->n_rows; row++) {
      printf ("T=%d S=%d R=%d : %s\n", tbl, seg, row, S->record[row]);
    }
  }
}
\end{verbatim}

\section{Prepare program options}
\index{Program options!Prepare}
\label{sec:func}
The module prototype interface is

\begin{verbatim}
int GMT_module (void *API, int mode, void *args);
\end{verbatim}
All GMT modules may be called with one of three sets of \texttt{args} depending on \texttt{mode}.
The three modes differ in how the options are passed to the module:
\begin{description}
\item [$mode > 0$]: Expects \texttt{args} to be an array of text options and \texttt{mode} to be a count of
how many options are passed (i.e., the \texttt{argc, argv[]} model).
\item [$mode < 0$]: Expects \texttt{args} to be a pointer to a doubly-linked list of objects with individual options
for the current program.
\item [$mode == 0$]: Expects \texttt{args} to be a single text string with all required options.
\end{description}
Here, \texttt{GMT\_module} stands for any of the \GMT\ modules, such as \texttt{GMT\_psxy}.
All modules returns FALSE (0) if they returned successfully; otherwise they return an error code
back to the calling environment.

\subsection{Set program options via text array arguments}
\index{Set program options via text array arguments}
\index{Program options!Text array arguments}

When \texttt{mode} $> 0$ we expect an array \texttt{args} of character strings that each
holds a single command line options (e.g., ``-R120:30/134:45/8S/3N'') and interpret \texttt{mode}
to be the count of how many options are passed.  This, of course, is almost exactly how the stand-alone \GMT\
programs are called (and reflects how they themselves are activated internally).  We call this the ``argc--argv'' mode.
Depending on how your program obtains the necessary options you may find that this interface offers all you need.

\subsection{Set program options via text command}
\index{Set program options via text command}
\index{Program options!Text command argument}

If \texttt{mode} == 0 then \texttt{args} will be examined to see if it contains several options within a single command string.
If so we will break these into separate options.  This is useful if you wish to pass a single string such as
``-R120:30/134:45/8S/3N -JM6i mydata.txt -Sc0.2c''.  We call this the ``command'' mode.

\subsection{Set program options via linked structures}
\index{Set program options via linked structures}
\index{Program options!Linked structures}

The third, linked-list interface allows developers using higher-level programming languages to pass all command
options via a pointer to a NULL-terminated, doubly-linked list of option structures, each containing
information about a single option.  Here, instead of text arguments we pass the pointer to the linked list of
options mentioned above, and \texttt{mode} must be passed as -1 (or any negative value).  Using
this interface can be more involved since you need to generate the linked
list of program options; however, utility functions exist to simplify its use.
This interface is intended for programs whose internal workings are better suited to
generate such arguments -- we call this the ``options'' mode.  The order in the list is not important as \GMT\ will sort it internally
according to need.  The option structure is defined in Table \ref{tbl:options}.
\begin{table}[h]
\small
\centering
\begin{tabular}{ll} \hline
\verb!struct GMT_OPTION {!        & \\
\verb!  char option;!             & /* \emph{Single character of the option (e.g.,'G' for} \Opt{G} */ \\
\verb!  char *arg;!               & /* \emph{String pointer with arguments (NULL if not used)} */ \\
\verb!  struct GMT_OPTION *next;! & /* \emph{Pointer to next option (NULL for last option)} */\\
\verb!  struct GMT_OPTION *prev;! & /* \emph{Pointer to previous option (NULL for first option)} */\\
\verb!};!                         & \\
\hline
\end{tabular}
\caption{Definition of the structure used to hold a single program option.}
\label{tbl:options}
\index{Option!Structure}
\end{table}

\subsection{Convert between text and linked structures}
\index{Convert between text and linked structures}
\index{Linked structures!Convert to text}
\index{Text options!Convert to linked structures}

To assist programmers there are also two convenience functions that
allow you to convert between the two argument formats.  They are

\begin{verbatim}
struct GMT_OPTIONS * GMT_Create_Options (void *API, int argc, void *args);
\end{verbatim}
\index{GMT\_Create\_Options}
This function accepts your array of text arguments (cast via a void pointer), allocates the necessary
space, performs the conversion, and returns a pointer to the
head of the linked list of program options.  However, in case of an error
we return a NULL pointer and set \texttt{API->error} to indicate the nature of the problem.
Otherwise, the pointer may now be passed to the
relevant \texttt{GMT\_module}.  Note that if your list of text arguments
were obtained from a C \texttt{main()} function then \texttt{argv[0]} will
contain the name of the calling program.  To avoid passing this as a file
name option, call \texttt{GMT\_Create\_Options} with \texttt{argc-1}
and \texttt{argv+1}.  If you wish to pass a single text string with
multiple options (in lieu of an array of text strings), then pass \texttt{arg} = 0.
When no longer needed you can remove the entire list by calling
\begin{verbatim}
int GMT_Destroy_Options (void *API, struct GMT_OPTION **list);
\end{verbatim}
\index{GMT\_Destroy\_Options}
The function returns TRUE (1) if there is an error (which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

The inverse function prototype is
\begin{verbatim}
char ** GMT_Create_Args (void *API, int *argc, struct GMT_OPTIONS *list);
\end{verbatim}
\index{GMT\_Create\_Args}
which allocates space for the text strings and performs the conversion;
it passes back the count of the arguments via \texttt{argc} and returns a pointer to the text array.
In the case of an error we return a NULL pointer and set \texttt{API->error} to reflect the error type.
Note that \texttt{argv[0]} will not contain the name of the program as
is the case the arguments presented by a C \texttt{main()} function.
When you no longer have any use for the text array, call
\begin{verbatim}
int GMT_Destroy_Args (void *API, int argc, char *argv[]);
\end{verbatim}
\index{GMT\_Destroy\_Args}
to deallocate the space used.  This function returns TRUE (1) if there is an error
(which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

Finally, to convert the linked list of option structures to a single
text string command, use
\begin{verbatim}
char * GMT_Create_Cmd (void *API, struct GMT_OPTION *list);
\end{verbatim}
\index{GMT\_Create\_Cmd}
Developers who plan to import and export \GMT\ shell scripts might find it
convenient to use these functions.  In case of an error we return a NULL pointer
and set \texttt{API->error}, otherwise a pointer to an allocated string is returned.
It 

\subsection{Manage the linked list of options}
\index{Manage the linked list of options}
\index{Option!Manage}
\index{Linked options!Manage}

Several additional utility functions are available for programmers who wish to manipulate
program option structures within their own programs.  These allow you to create new
option structures, append them to the linked list, replace existing options with new
values, find a particular option, and remove options from the list.  Note: The
order in which the options appear in the linked list is of no consequence to \GMT.
Internally, \GMT\ will sort and process the options in the manner required.
Externally, you are free to maintain your own order.

\subsubsection{Make a new option structure}
\index{Make a new option structure}
\index{Option!Make}

\texttt{GMT\_Make\_Option} will allocate a new option structure, assign it values
given the \texttt{option} and \texttt{arg} parameter (pass NULL if there is no
argument for this option), and returns a pointer
to the allocated structure.  The prototype is
\index{GMT\_Make\_Option}

\begin{verbatim}
struct GMT_OPTION *GMT_Make_Option (void *API, char option, char *arg);
\end{verbatim}
Should memory allocation fail the function will print an error message
set an error code via \texttt{API->error}, and return NULL.

\subsubsection{Append an option to the linked list}
\index{Append an option to the linked list}
\index{Option!Append}

\texttt{GMT\_Append\_Option} will append the specified \texttt{option} to the end
of the doubly-linked \texttt{list}.  The prototype is
\index{GMT\_Append\_Option}

\begin{verbatim}
struct GMT_OPTION * GMT_Append_Option (void *API, \
    struct GMT_OPTION *option, struct GMT_OPTION *list);
\end{verbatim}
We return the list back, and if \texttt{list} is given as NULL we return \texttt{option} as the start of the new list.
Any errors results in a NULL pointer with \texttt{API->error} holding the error type.

\subsubsection{Find an option in the linked list}
\index{Find an option in the linked list}
\index{Option!Find}

\texttt{GMT\_Find\_Option} will return a pointer \texttt{ptr} to the first option in the linked list starting
at \texttt{list} whose option character equals \texttt{option}.  If not found we return NULL.  While this is
not necessarily an error we still set \texttt{API->error} accordingly.
The prototype is
\index{GMT\_Find\_Option}

\begin{verbatim}
struct GMT_OPTION *GMT_Find_Option (void *API, \
    char option, struct GMT_OPTION *list);
\end{verbatim}
If you need to look for multiple occurrences of a certain option you will need to
call \texttt{GMT\_Find\_Option} again, passing the option following the
previously found option as the \texttt{list} entry, i.e.,

\begin{verbatim}
list = *ptr->next;
\end{verbatim}

\subsubsection{Update an existing option in the list}
\index{Update an existing option in the list}
\index{Option!Update}

\texttt{GMT\_Update\_Option} will first determine if \texttt{option} exists;
if so it will delete it. Then, it will make a new option from the arguments
and append it to the end of the linked \texttt{list}.  The prototype is
\index{GMT\_Update\_Option}

\begin{verbatim}
int GMT_Update_Option (void *API, char option, \
    char *arg, struct GMT_OPTION *list);
\end{verbatim}
An error will be reported if (a) \texttt{list} is NULL or (b) the option is not found.
The function returns TRUE (1) if there is an error (i.e., \texttt{list} is NULL or the
option is not found); the error code is passed back via \texttt{API->error}.
Otherwise it returns FALSE (0).

\subsubsection{Delete an existing option in the linked list}
\index{Delete an existing option in the linked list}
\index{Option!Delete}

You may use \texttt{GMT\_Delete\_Option} to remove \texttt{option} from
the linked \texttt{list}.  The prototype is
\index{GMT\_Delete\_Option}

\begin{verbatim}
int GMT_Delete_Option (void *API, struct GMT_OPTION *current);
\end{verbatim}
We return TRUE if the option is not found in the list and set \texttt{API->error} accordingly.
Note: Only the first occurrence of the specified option will be deleted.  If you need to delete all such
options you will need to call this function in a loop until it returns a non-zero
status.

\subsubsection{Specify a file via an linked option}
\index{Specify a file via an linked option}
\index{Option!Files}

To specify an input file name via an option, simply use $<$ as the option (this is what
\texttt{GMT\_Create\_Options} does when it finds filenames on the command line).
Likewise, $>$ can be used to explicitly indicate an output file.  In order to append to
an existing file, use $>>$.  For example the following command would read from file.A
and append to file.B:

\begin{verbatim}
gmtconvert -<file.A ->>file.B
\end{verbatim}

These options also work on the command line but usually one would have to escape the
special characters $<$ and $>$ as they are used for file redirection.

\subsection{Parsing GMT common options}
\index{Parsing GMT common options}

While all the main \GMT\ modules have their own specific option parser, we also provide a general
parser that only examines the common \GMT\ options such as \Opt{R}, \Opt{J}, \Opt{V}, etc.  The prototype
of this parser is

\index{GMT\_Parse\_Common}

\begin{verbatim}
int GMT_Parse_Common (void *API, char *args, struct GMT_OPTION *list);
\end{verbatim}

where \texttt{args} is a string of the common \GMT\ options your program may use.
An error will be reported via \texttt{API->error} if any of the common \GMT\ options fail to parse,
and if so we return TRUE; if not errors we return FALSE.  All other options,
including file names, will be silently ignored.  The parsing will update the internal \GMT\
information structure that affects program operations.

\section{Calling a GMT module}
\index{Calling a GMT module}

Given your linked list of program options (or text array) and possibly some registered resources, you
can now call the required \GMT\ module using one of the two flavors discussed in section {\ref{sec:func}}.
All modules return an error or status code that your program should consider before processing the results.

\section{Adjusting headers and comments}
\index{Adjusting headers and comments}
\index{Headers}
\index{Comments}

All header records in incoming datasets are stored in memory.  You may wish to replace these records with
new information, or append new information to the existing headers.  This is achieved with

\index{GMT\_Set\_Comment}

\begin{verbatim}
int GMT_Set_Comment (void *API, unsigned int family, unsigned int mode \
    void *arg, void *data)
\end{verbatim}

Again, \texttt{family} selects which kind of resource is passed via \texttt{data}. The \texttt{mode}
determines what kind of comment is being considered, how it should be included, and in what form the comment
passed via \texttt{arg} is.  Table~\cite{tbl:comments} lists the available options, which may be combined
by adding (bitwise ``or'').  The \texttt{GMT\_Set\_Comment} does not actually output anything but sets the
relevant comment and header records in the relevant structure.  When a file is written out the information
will be output as well (Note: Users can always decide if they wish to turn header output on or off via the
common \GMT\ option \Opt(h).  For record-by-record writing you must enable the header block output when
you call \texttt{GMT\_Begin\_IO}.
\index{GMT\_Begin\_IO}

\begin{table}[h]
\small
\centering
\begin{tabular}{|l|l|l|} \hline
\multicolumn{1}{|c|}{\emph{constant}} & \multicolumn{1}{c|}{\emph{value}}  & \multicolumn{1}{c|}{\emph{Description}} \\ \hline
GMT\_COMMENT\_IS\_TEXT		&      0	& Comment is a text string \\ \hline
GMT\_COMMENT\_IS\_OPTION	&      1	& Comment is a linked list of GMT\_OPTION structures \\ \hline
GMT\_COMMENT\_IS\_COMMAND	&      2	& Comment is the command \\ \hline
GMT\_COMMENT\_IS\_REMARK	&      4	& Comment is the remark \\ \hline
GMT\_COMMENT\_IS\_TITLE		&      4	& Comment is the title \\ \hline
GMT\_COMMENT\_IS\_NAME_X	&      4	& Comment is the x variable name (grids only) \\ \hline
GMT\_COMMENT\_IS\_NAME_Y	&      4	& Comment is the y variable name (grids only) \\ \hline
GMT\_COMMENT\_IS\_NAME_Z	&      4	& Comment is the z variable name (grids only) \\ \hline
GMT\_COMMENT\_IS\_COLNAMES	&      4	& Comment is the column names header \\ \hline
GMT\_COMMENT\_IS\_RESET		&      8	& Comment replaces existing information \\ \hline
\end{tabular}
\caption{Enumeration constants as bit-flags defined for specifying different types of comments.}
\label{tbl:comments}
\index{Resources!Comments!types}
\end{table}
\index{GMT\_COMMENT\_IS\_TEXT}
\index{GMT\_COMMENT\_IS\_OPTION}
\index{GMT\_COMMENT\_IS\_COMMAND}
\index{GMT\_COMMENT\_IS\_REMARK}
\index{GMT\_COMMENT\_IS\_RESET}
The named modes (\emph{command}, \emph{remark}, \emph{title}, \emph{name\_x,y,z} and \emph{colnames} are used
to distinguish regular text comments from specific fields in the
header structures of the data resources, such as \texttt{GMT\_GRID}.  For the various table resources (e.g., \texttt{GMT\_DATASET})
these modifiers result in a specially formatted comments beginning with ``Command: '' or ``Remark: '', reflecting how this
type of information is encoded in the headers.

\section{Exporting Data}
\index{Exporting Data}
\index{Data!Export data}
\index{Resources!Export data}

If your program needs to write any of the four recognized data types (CPT files, data tables, text tables, or \GMT\ grids)
you can use the \texttt{GMT\_Put\_Data}. In the case of data and text tables, you may also consider the
\texttt{GMT\_Put\_Record} function.
As a general rule, your program organization may simplify if you can write the export the entire resource with
\texttt{GMT\_Put\_Data}.  However, if the program logic is simple or already involves using \texttt{GMT\_Get\_Record},
it may be better to export one data record at the time via \texttt{GMT\_Put\_Record}.


Both of these output functions takes a parameter called \texttt{mode}.  The \texttt{mode} parameter generally
takes on different meanings for the different data types and will be discussed below.
However, one bit setting is common to all types: By default, you are only allowed to write a
data resource once; the resource is then flagged to have been written and subsequent attempts to write
to the same resource will quietly be ignored.  In the unlikely event you need to re-write a
resource you can override this default behavior by adding GMT\_IO\_RESET to your \texttt{mode} parameter.

\subsection{Enable Data Export}
\index{Export!Enable}
\index{Data!Export}
\index{Resources!Export data}

Similar to the data import procedures, once all output destinations have been registered, we signal the API that we are done with the registration
phase and are ready to start the actual data export.  As for input, this step is only needed when dealing with record-by-record writing.
Again, we enable record-by-record writing by calling \texttt{GMT\_Begin\_IO}, this time with \texttt{direction} = GMT\_OUT.
This function enables data export and prepares the registered destinations for the upcoming writing.  


\subsection{Exporting a data set}
\index{Exporting a data set}
\index{Data!Export data set}
\index{Resources!Export data set}

To have your program accept results from \GMT\ modules and write them
separately requires you to use the \texttt{GMT\_Write\_Data} or \texttt{GMT\_Put\_Data} functions.  They are
very similar to the \texttt{GMT\_Read\_Data} and \texttt{GMT\_Get\_Data} functions encountered earlier.

\subsubsection{Exporting a data set to a file, stream, or handle}
\index{GMT\_Write\_Data}
The prototype for writing to a file (via name, stream, or file handle) is

\begin{verbatim}
int GMT_Write_Data (void *API, unsigned int family, \
    unsigned int method, unsigned int geometry, unsigned int mode, \
    double wesn[], void *output, void *data);
\end{verbatim}
where \texttt{data} is a pointer to any of the four structures
discussed previously.  Again, the \texttt{mode} parameter is specific to
each data type:

\begin{description}
\item [CPT table]: \texttt{mode} controls if the CPT table's back-, fore-, and NaN-colors
should be written (1) or not (0).
\item [Data table]: If \texttt{method} is GMT\_IS\_FILE, then the value of
\texttt{mode} affects how the data set is written:
\begin{description}
\item [GMT\_WRITE\_SET]: The entire data set will be written to the single file [0].
\index{GMT\_WRITE\_SET}
\item [GMT\_WRITE\_TABLE]: Each table in the data set is written to individual files [1].
You can either specify an output file name that \emph{must} contain one C-style
format specifier for a int variable (e.g., ``New\_Table\_\%06d.txt''), which will be
replaced with the table number (a running number from 0) \emph{or} you must assign
to each table \emph{i} a unique output file name via the \texttt{D->table[i]->file[GMT\_OUT]}
variables prior to calling the function.
\index{GMT\_WRITE\_TABLE}
\item [GMT\_WRITE\_SEGMENT]: Each segment in the data set is written to an individual file [2].
Same setup as for GMT\_WRITE\_TABLE except we use sequential segment numbers to build the file names.
\index{GMT\_WRITE\_SEGMENT}
\item [GMT\_WRITE\_TABLE\_SEGMENT]: Each segment in the data set is written to an individual file [3].
You can either specify an output file name that \emph{must} contain two C-style
format specifiers for two int variables (e.g., ``New\_Table\_\%06d\_Segment\_\%03d.txt''),
which will be replaced with the table and segment numbers, \emph{or}
you must assign to each segment \emph{j} in each table \emph{i} a unique output file name
via the \texttt{D->table[i]->segment[j]->file[GMT\_OUT]} variables prior to calling the function.
\index{GMT\_WRITE\_TABLE\_SEGMENT}
\index{GMT\_WRITE\_OGR}
\item [GMT\_WRITE\_OGR]: Writes the dataset in OGR/GMT format in conjunction with the \Opt{a} setting [4].
\end{description}
\item [Text table]: The \texttt{mode} is used the same way as for data tables.
\item [GMT grid]: Here, \texttt{mode} may be GMT\_GRID\_HEADER\_ONLY to only update a file's header
structure, but normally it is simply GMT\_GRID\_ALL (0) so the entire
grid and its header will be exported (a subset is not allowed during export).
However, in the event your data array holds both the real and imaginary parts of a
complex data set you must add either GMT\_GRID\_IS\_COMPLEX\_REAL (4) or GMT\_GRID\_IS\_COMPLEX\_IMAG (16) to \texttt{mode}
so as to export the corresponding grid values correctly.  Finally, for native binary grids you may skip writing
the grid header by adding GMT\_GRID\_NO\_HEADER (16); this setting is ignored for other grid formats.
If your output grid is huge and you are building it row-by-row, set \texttt{mode} to
GMT\_GRID\_HEADER\_ONLY | GMT\_GRID\_ROW\_BY\_ROW.  You can then write the grid row-by-row
using \texttt{GMT\_Put\_Row}.  By default the rows will be automatically
processed in order.  To completely specify which row to be written, use GMT\_GRID\_ROW\_BY\_ROW\_MANUAL
instead.
\index{GMT\_GRID\_HEADER\_ONLY}
\index{GMT\_GRID\_ALL}
\index{GMT\_GRID\_IS\_COMPLEX\_REAL}
\index{GMT\_GRID\_IS\_COMPLEX\_IMAG}
\index{GMT\_GRID\_NO\_HEADER}
\index{GMT\_GRID\_ROW\_BY\_ROW}
\index{GMT\_GRID\_ROW\_BY\_ROW\_MANUAL}
\end{description}
If successful the function returns FALSE (0); otherwise we return TRUE (1) and set \texttt{API->error} to reflect to cause.

\subsubsection{Exporting a data set to memory}
\index{GMT\_Put\_Data}

If writing to a memory destination you will want to first register that destination and then use the returned ID with
\texttt{GMT\_Put\_Data} instead:

\begin{verbatim}
int GMT_Put_Data (void *API, int ID, unsigned int mode, void *data);
\end{verbatim}
where \texttt{ID} is the unique ID of the registered destination, \texttt{mode}
is specific to each data type (and controls aspects of the output structuring),
and \texttt{data} is a pointer to any of the four structures
discussed previously.  For more detail, see \texttt{GMT\_Write\_Data} above.
If successful the function returns FALSE (0); otherwise we return TRUE (1) and set \texttt{API->error} to reflect to cause.


\subsection{Exporting a data record}
\index{Exporting a data record}
\index{Data!Export data record}
\index{Resources!Export data record}

If your program must write data table records one-by-one you must first enable record-by-record
writing with \texttt{GMT\_Begin\_IO} and then use the \texttt{GMT\_Put\_Record} function in a loop;
the prototype is
\index{GMT\_Put\_Record}

\begin{verbatim}
int GMT_Put_Record (void *API, unsigned int mode, void *rec);
\end{verbatim}
where \texttt{rec} is a pointer to either (a) a double-precision array with the current row.
Then, \texttt{rec} is expected to hold at least as many items as the current setting of
\texttt{n\_col[GMT\_OUT]}, which represents the number of columns in the output destination.
Alternatively (b), \texttt{rec} points to a text string.
The \texttt{mode} parameter must be set to reflect what is passed.  Using \texttt{GMT\_Put\_Record}
requires you to first initialize the destination with \texttt{GMT\_Init\_IO}.
Note that for families GMT\_IS\_DATASET and GMT\_IS\_TEXTSET the methods GMT\_IS\_DUPLICATE and GMT\_IS\_REFERENCE are not supported since
you can simply populate the GMT\_DATASET structure directly.
As mentioned, \texttt{mode} affects what is actually written:
\begin{description}
\item [GMT\_WRITE\_DOUBLE]: Normal operation that builds the current output record from
the values in \texttt{rec} [0].
\index{GMT\_WRITE\_DOUBLE}
\item [GMT\_WRITE\_TEXT]: For ASCII output mode we write the text string \texttt{rec}.
If \texttt{rec} is NULL then we use the current (last imported) text record.
If binary output mode we quietly skip writing this record [1].
\index{GMT\_WRITE\_TEXT}
\item [GMT\_WRITE\_TABLE\_HEADER]: For ASCII output mode we write the text string \texttt{rec}.
If \texttt{rec} is NULL then we write the last read
header record (and ensures it starts with \#). If binary output mode we quietly skip writing this record [2].
\index{GMT\_WRITE\_TABLE\_HEADER}
\item [GMT\_WRITE\_SEGMENT\_HEADER]: For ASCII output mode we use the text string \texttt{rec} as the segment header.
If \texttt{rec} is NULL then we use the current (last read) segment header record.
If binary output mode instead we write a record composed of NaNs [1].
\index{GMT\_WRITE\_SEGMENT\_HEADER}
\end{description}
The function returns TRUE (1) if there was an error associated with the writing (which is passed back with \texttt{API->error}),
otherwise it returns FALSE (0).

\subsection{Exporting a grid row}
\index{Exporting a grid row}
\index{Data!Export grid row}
\index{Resources!Export grid row}

If your program must write a grid file row-by-row you must first enable row-by-row
writing with \texttt{GMT\_Read\_Data} and then use the \texttt{GMT\_Put\_Row} function in a loop;
the prototype is
\index{GMT\_Put\_Row}

\begin{verbatim}
int GMT_Put_Row (void *API, int row_no, struct GMT_GRID *G, float *row);
\end{verbatim}
where \texttt{row} is a pointer to a single-precision array with the current row,
\texttt{G} is the grid in question, and \texttt{row\_no} is the number of the current
row to be written.  Note this value is only considered if the row-by-row mode was
initialized with GMT\_GRID\_ROW\_BY\_ROW\_MANUAL.

\subsection{Disable Data Export}
\index{Export!Disable}
\index{Data!Export}
\index{Resources!Export data}

Once the record-by-record output has completed we disable further output to prevent accidental
writing from occurring (due to poor program structure, bugs, etc.).  We do so by calling \texttt{GMT\_End\_IO}.  This
function disables further record-by-record data export; here, we obviously pass \texttt{direction} = GMT\_OUT.

\section{Destroy allocated resources}
\index{Destroy allocated resources}
\index{Resources!Destroy}

If your session imported any data sets into memory then you may explicitly free this
memory once it is no longer needed and before terminating the session.
This is done with the \texttt{GMT\_Destroy\_Data} function, whose prototype is
\index{GMT\_Destroy\_Data}

\begin{verbatim}
int GMT_Destroy_Data (void *API, unsigned int mode, void *data);
\end{verbatim}
where \texttt{data} is the address of the pointer to a data container.
Pass \texttt{mode} either as GMT\_ALLOCATED or GMT\_REFERENCE.  The former
is used internally by the \GMT\ modules since they can only free resources that are
not destined to live on in the memory of their calling program.  The latter mode is used
to free resources in your calling program.  Note that when each module completes it will
automatically free memory created by the API; similarly, when the session is destroyed
we also automatically free up memory.  Thus, \texttt{GMT\_Destroy\_Data} is therefore
generally only needed when you wish to directly free up memory to avoid running out of it.
\index{GMT\_ALLOCATED}
\index{GMT\_REFERENCE}
The function returns TRUE (1) if there is an error when trying to free the memory
(the error code is passed back with \texttt{API->error}), otherwise it returns FALSE (0).

\section{Terminate a GMT session}
\index{Terminate a GMT session}
\index{GMT session!Terminate}

Before your program exits it should properly terminate the \GMT\ session, which involves a call to

\begin{verbatim}
int GMT_Destroy_Session (void *API);
\end{verbatim}
\index{GMT\_Destroy\_Session}
which simply takes the pointer to the \GMT\ API control structure as its only arguments.  It 
terminates the \GMT\ machinery and deallocates all memory used by the \GMT\ API book-keeping.
It also unregisters any remaining resources previously registered with the session.
The \GMT\ API will only close files that it was responsible for opening in the first place.
Finally, the API structure itself is freed so your main program does not need to do so.
The function returns TRUE (1) if there is an error when trying to free the memory
(the error code is passed back with \texttt{API->error}), otherwise it returns FALSE (0).

\section{FORTRAN 77 interface} 
\index{FORTRAN 77 interface}
\index{Interface!FORTRAN 77}

FORTRAN 77 developers who wish to use the \GMT\ API may use the same 22 API functions as discussed in Chapter 2.
However, as pointers to structures and such are not available, the FORTRAN bindings provided simplifies the
interface in two ways:
\begin{itemize}
\item The first argument to the functions (the GMTAPI Control structure pointer) is not provided.  Instead,
the bindings use a hidden, global external structure for this purpose and pass the pointer to it down to
the C version of the functions.
\item The resource arguments in \texttt{GMT\_Register\_IO} are not pointers to
items but the items themselves.
\end{itemize}
The list of the basic 22 FORTRAN prototype functions thus becomes
\begin{verbatim}
function GMT_Create_Session (tag, pad, mode)
function GMT_Destroy_Session ()
function GMT_Register_IO (family, method, geometry, direction, \
    wesn, resource)
function GMT_Encode_ID (filename, ID)
function GMT_Init_IO (family, geometry, direction, mode, n_args, args)
function GMT_Begin_IO (family, geometry, direction)
function GMT_Status_IO (mode)
function GMT_Create_Data (family, geometry, ipar)
function GMT_Duplicate_Data (family, mode, data)
function GMT_Read_Data (family, method, geometry, mode, wesn, \
    input, data)
function GMT_Get_Data (ID, mode, data)
function GMT_Retrieve_Data (ID)
function GMT_Get_Record (rec, mode, nfields)
function GMT_Get_Row (row_no, grid, row)
function GMT_Write_Data (family, method, geometry, mode, wesn, \
    output, data)
function GMT_Put_Data (ID, mode, data)
function GMT_Put_Record (mode, rec)
function GMT_Put_Row (row_no, grid, row)
function GMT_End_IO (direction, mode)
function GMT_Destroy_Data (mode, ptr)
\end{verbatim}
where \texttt{family}, \texttt{method}, \texttt{geometry}, \texttt{mode} and \texttt{direction}
are unsigned ints, \texttt{ID} and \texttt{error} are (signed) integers,
\texttt{ipar} is an integer parameter array, \texttt{wesn} is a real (double precision) array,
and \texttt{resource} are source or destination addresses.

\clearpage
%\addcontentsline{toc}{chapter}{INDEX}
\printindex

\end{document}
