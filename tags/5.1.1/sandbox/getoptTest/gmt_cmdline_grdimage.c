/*
  File autogenerated by gengetopt version 2.22.6
  generated with the following command:
  /opt/local/bin/gengetopt --no-version --no-help -l --unamed-opts=grd_z or grd_r grd_g grd_b --input=gmt_grdimage.ggo --unamed-opts --no-handle-error --no-handle-help --no-handle-version --func-name=gmt_cmdline_parser --file-name=gmt_cmdline_grdimage

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif

#include <getopt.h>

#include "gmt_cmdline_grdimage.h"

const char *gengetopt_args_info_purpose = "Project grids or images and plot them on maps";

const char *gengetopt_args_info_usage = "Usage: grdimage -Ccptfile|--cpt-file=cptfile -Jparameters|--proj=parameters \n         [-Iintensgrid|--intens-file=intensgrid] [-?|--help] [--full-help] \n         [-^|--detailed-help] [--version] [grd_z or grd_r grd_g grd_b]...";

const char *gengetopt_args_info_description = "grd_z is data set to be plotted.  Its z-values are in user units and will be \nconverted to rgb colors via the cpt file.  Alternatively, give three separate \ngrid files that contain the red, green, and blue components in the 0-255 range. \nIf -D is used then grd_z is instead expected to be an image";

const char *gengetopt_args_info_detailed_help[] = {
  "Mandatory arguments:",
  "  -C, --cpt-file=cptfile        Color palette file to convert z to rgb",
  "  -J, --proj[=parameters]       Select map proJection",
  "  The projection type is identified by a 1- or 2-character ID (e.g. 'm' or \n  'kf') or by an abbreviation followed by a slash (e.g. 'cyl_stere/'). When \n  using a lower-case ID <scale> can be given either as 1:<xxxx> or in cm/degree \n  along the standard parallel. Alternatively, when the projection ID is \n  Capitalized, <scale>|<width> denotes the width of the plot in cm Append h for \n  map height, + for max map dimension, and - for min map dimension. When the \n  central meridian (lon0) is optional and omitted, the center of the longitude \n  range specified by -R is used. The default standard parallel is the equator \n  Azimuthal projections set -Rg unless polar aspect or -R<...>r is given.",
  "\nAdditional arguments:",
  "  -B, --boundary=[p|s]xinfo[/yinfo[/zinfo]][:.Title:][W|w][E|e][S|s][N|n][Z|z[+]][+gfill]\n                                Basemap boundary annotation attributes",
  "  -I, --intens-file=intensgrid  Use illumination. Give name of intensity grid \n                                  file",
  "  -K, --more                    Allow for more plot code to be appended later",
  "  -O, --over                    Set Overlay plot mode, i.e., append to an \n                                  existing plot",
  "  -P, --portrait                Set Portrait page orientation  (default=off)",
  "  -R, --region[=west/east/south/north[/zmin/zmax][r]]\n                                Specify the min/max coordinates of data region \n                                  in user units",
  "  -U, --time[=[just/dx/dy/][c|label]]\n                                Plot Unix System Time stamp [and optionally \n                                  appended text]",
  "  -V, --verbose[=level]         Change the verbosity level  (default=`1')",
  "  Choose among 5 levels; each level adds more messages:\n     0 - Complete silence, not even fatal error messages\n     1 - Fatal error messages [Default when no -V is used]\n     2 - Warnings and progress messages [Default when -V is used]\n     3 - Detailed progress messages\n     4 - Debugging messages",
  "  -X, --shift-x[=xshift]        X-shift origin of plot",
  "  -Y, --shift-y[=yshift]        Y-shift origin of plot",
  "  -c, --copies[=ncopies]        Specify the number of copies  (default=`1')",
  "  -f, --data-type[=[i|o]colinfo]\n                                Special formatting of input/output columns \n                                  (time or geographical)",
  "  -h, --header[=[i|o][n]]       Input file has header records",
  "  -/, --swap[=[i|o]]            Swap 1st and 2nd column on input and/or output",
  "      --output=[outfile]        Output file  (default=`stdout')",
  "\nHelp:",
  "  -?, --help                    Show help (required arguments only), and exit",
  "      --full-help               Show help, including hidden options, and exit",
  "  -^, --detailed-help           Show help, including all details and hidden \n                                  options, and exit",
  "      --version                 Print version and exit",
  "\nPlease refer to the manual for further explanations.",
    0
};
static void
init_full_help_array(void)
{
  gengetopt_args_info_full_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_full_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_full_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_full_help[3] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_full_help[4] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_full_help[5] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_full_help[6] = gengetopt_args_info_detailed_help[7];
  gengetopt_args_info_full_help[7] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_full_help[8] = gengetopt_args_info_detailed_help[9];
  gengetopt_args_info_full_help[9] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_full_help[10] = gengetopt_args_info_detailed_help[11];
  gengetopt_args_info_full_help[11] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_full_help[12] = gengetopt_args_info_detailed_help[14];
  gengetopt_args_info_full_help[13] = gengetopt_args_info_detailed_help[15];
  gengetopt_args_info_full_help[14] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_full_help[15] = gengetopt_args_info_detailed_help[17];
  gengetopt_args_info_full_help[16] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_full_help[17] = gengetopt_args_info_detailed_help[19];
  gengetopt_args_info_full_help[18] = gengetopt_args_info_detailed_help[20];
  gengetopt_args_info_full_help[19] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_full_help[20] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_full_help[21] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_full_help[22] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_full_help[23] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_full_help[24] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_full_help[25] = 0; 
  
}

const char *gengetopt_args_info_full_help[26];

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_help[4] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_help[5] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_help[6] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_help[7] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_help[8] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_help[9] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_help[10] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_help[11] = 0; 
  
}

const char *gengetopt_args_info_help[12];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
} gmt_cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
gmt_cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct gmt_cmdline_parser_params *params, const char *additional_error);

static int
gmt_cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->cpt_file_given = 0 ;
  args_info->proj_given = 0 ;
  args_info->boundary_given = 0 ;
  args_info->intens_file_given = 0 ;
  args_info->more_given = 0 ;
  args_info->over_given = 0 ;
  args_info->portrait_given = 0 ;
  args_info->region_given = 0 ;
  args_info->time_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->shift_x_given = 0 ;
  args_info->shift_y_given = 0 ;
  args_info->copies_given = 0 ;
  args_info->data_type_given = 0 ;
  args_info->header_given = 0 ;
  args_info->swap_given = 0 ;
  args_info->output_given = 0 ;
  args_info->help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->detailed_help_given = 0 ;
  args_info->version_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->cpt_file_arg = NULL;
  args_info->cpt_file_orig = NULL;
  args_info->proj_arg = NULL;
  args_info->proj_orig = NULL;
  args_info->boundary_arg = NULL;
  args_info->boundary_orig = NULL;
  args_info->intens_file_arg = NULL;
  args_info->intens_file_orig = NULL;
  args_info->portrait_flag = 0;
  args_info->region_arg = NULL;
  args_info->region_orig = NULL;
  args_info->time_arg = NULL;
  args_info->time_orig = NULL;
  args_info->verbose_arg = 1;
  args_info->verbose_orig = NULL;
  args_info->shift_x_arg = NULL;
  args_info->shift_x_orig = NULL;
  args_info->shift_y_arg = NULL;
  args_info->shift_y_orig = NULL;
  args_info->copies_arg = 1;
  args_info->copies_orig = NULL;
  args_info->data_type_arg = NULL;
  args_info->data_type_orig = NULL;
  args_info->header_arg = NULL;
  args_info->header_orig = NULL;
  args_info->swap_arg = NULL;
  args_info->swap_orig = NULL;
  args_info->output_arg = NULL;
  args_info->output_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  init_full_help_array(); 
  init_help_array(); 
  args_info->cpt_file_help = gengetopt_args_info_detailed_help[1] ;
  args_info->proj_help = gengetopt_args_info_detailed_help[2] ;
  args_info->boundary_help = gengetopt_args_info_detailed_help[5] ;
  args_info->intens_file_help = gengetopt_args_info_detailed_help[6] ;
  args_info->more_help = gengetopt_args_info_detailed_help[7] ;
  args_info->over_help = gengetopt_args_info_detailed_help[8] ;
  args_info->portrait_help = gengetopt_args_info_detailed_help[9] ;
  args_info->region_help = gengetopt_args_info_detailed_help[10] ;
  args_info->time_help = gengetopt_args_info_detailed_help[11] ;
  args_info->verbose_help = gengetopt_args_info_detailed_help[12] ;
  args_info->shift_x_help = gengetopt_args_info_detailed_help[14] ;
  args_info->shift_y_help = gengetopt_args_info_detailed_help[15] ;
  args_info->copies_help = gengetopt_args_info_detailed_help[16] ;
  args_info->data_type_help = gengetopt_args_info_detailed_help[17] ;
  args_info->data_type_min = 0;
  args_info->data_type_max = 0;
  args_info->header_help = gengetopt_args_info_detailed_help[18] ;
  args_info->swap_help = gengetopt_args_info_detailed_help[19] ;
  args_info->output_help = gengetopt_args_info_detailed_help[20] ;
  args_info->help_help = gengetopt_args_info_detailed_help[22] ;
  args_info->full_help_help = gengetopt_args_info_detailed_help[23] ;
  args_info->detailed_help_help = gengetopt_args_info_detailed_help[24] ;
  args_info->version_help = gengetopt_args_info_detailed_help[25] ;
  
}

void
gmt_cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(GMT_CMDLINE_PARSER_PACKAGE_NAME) ? GMT_CMDLINE_PARSER_PACKAGE_NAME : GMT_CMDLINE_PARSER_PACKAGE),
     GMT_CMDLINE_PARSER_VERSION);
}

static void print_help_common(void) {
  gmt_cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
gmt_cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
gmt_cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
gmt_cmdline_parser_print_detailed_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_detailed_help[i])
    printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}

void
gmt_cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void
gmt_cmdline_parser_params_init(struct gmt_cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct gmt_cmdline_parser_params *
gmt_cmdline_parser_params_create(void)
{
  struct gmt_cmdline_parser_params *params = 
    (struct gmt_cmdline_parser_params *)malloc(sizeof(struct gmt_cmdline_parser_params));
  gmt_cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}

/** @brief generic value variable */
union generic_value {
    int int_arg;
    char *string_arg;
    const char *default_string_arg;
};

/** @brief holds temporary values for multiple options */
struct generic_list
{
  union generic_value arg;
  char *orig;
  struct generic_list *next;
};

/**
 * @brief add a node at the head of the list 
 */
static void add_node(struct generic_list **list) {
  struct generic_list *new_node = (struct generic_list *) malloc (sizeof (struct generic_list));
  new_node->next = *list;
  *list = new_node;
  new_node->arg.string_arg = 0;
  new_node->orig = 0;
}


static void
free_multiple_string_field(unsigned int len, char ***arg, char ***orig)
{
  unsigned int i;
  if (*arg) {
    for (i = 0; i < len; ++i)
      {
        free_string_field(&((*arg)[i]));
        free_string_field(&((*orig)[i]));
      }
    free_string_field(&((*arg)[0])); /* free default string */

    free (*arg);
    *arg = 0;
    free (*orig);
    *orig = 0;
  }
}

static void
gmt_cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->cpt_file_arg));
  free_string_field (&(args_info->cpt_file_orig));
  free_string_field (&(args_info->proj_arg));
  free_string_field (&(args_info->proj_orig));
  free_string_field (&(args_info->boundary_arg));
  free_string_field (&(args_info->boundary_orig));
  free_string_field (&(args_info->intens_file_arg));
  free_string_field (&(args_info->intens_file_orig));
  free_string_field (&(args_info->region_arg));
  free_string_field (&(args_info->region_orig));
  free_string_field (&(args_info->time_arg));
  free_string_field (&(args_info->time_orig));
  free_string_field (&(args_info->verbose_orig));
  free_string_field (&(args_info->shift_x_arg));
  free_string_field (&(args_info->shift_x_orig));
  free_string_field (&(args_info->shift_y_arg));
  free_string_field (&(args_info->shift_y_orig));
  free_string_field (&(args_info->copies_orig));
  free_multiple_string_field (args_info->data_type_given, &(args_info->data_type_arg), &(args_info->data_type_orig));
  free_string_field (&(args_info->header_arg));
  free_string_field (&(args_info->header_orig));
  free_string_field (&(args_info->swap_arg));
  free_string_field (&(args_info->swap_orig));
  free_string_field (&(args_info->output_arg));
  free_string_field (&(args_info->output_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}

static void
write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])
{
  int i;
  
  for (i = 0; i < len; ++i)
    write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
}

int
gmt_cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", GMT_CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->cpt_file_given)
    write_into_file(outfile, "cpt-file", args_info->cpt_file_orig, 0);
  if (args_info->proj_given)
    write_into_file(outfile, "proj", args_info->proj_orig, 0);
  if (args_info->boundary_given)
    write_into_file(outfile, "boundary", args_info->boundary_orig, 0);
  if (args_info->intens_file_given)
    write_into_file(outfile, "intens-file", args_info->intens_file_orig, 0);
  if (args_info->more_given)
    write_into_file(outfile, "more", 0, 0 );
  if (args_info->over_given)
    write_into_file(outfile, "over", 0, 0 );
  if (args_info->portrait_given)
    write_into_file(outfile, "portrait", 0, 0 );
  if (args_info->region_given)
    write_into_file(outfile, "region", args_info->region_orig, 0);
  if (args_info->time_given)
    write_into_file(outfile, "time", args_info->time_orig, 0);
  if (args_info->verbose_given)
    write_into_file(outfile, "verbose", args_info->verbose_orig, 0);
  if (args_info->shift_x_given)
    write_into_file(outfile, "shift-x", args_info->shift_x_orig, 0);
  if (args_info->shift_y_given)
    write_into_file(outfile, "shift-y", args_info->shift_y_orig, 0);
  if (args_info->copies_given)
    write_into_file(outfile, "copies", args_info->copies_orig, 0);
  write_multiple_into_file(outfile, args_info->data_type_given, "data-type", args_info->data_type_orig, 0);
  if (args_info->header_given)
    write_into_file(outfile, "header", args_info->header_orig, 0);
  if (args_info->swap_given)
    write_into_file(outfile, "swap", args_info->swap_orig, 0);
  if (args_info->output_given)
    write_into_file(outfile, "output", args_info->output_orig, 0);
  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->detailed_help_given)
    write_into_file(outfile, "detailed-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
gmt_cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", GMT_CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = gmt_cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
gmt_cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  gmt_cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static char *
get_multiple_arg_token(const char *arg)
{
  const char *tok;
  char *ret;
  size_t len, num_of_escape, i, j;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');
  num_of_escape = 0;

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
          ++num_of_escape;
        }
      else
        break;
    }

  if (tok)
    len = (size_t)(tok - arg + 1);
  else
    len = strlen (arg) + 1;

  len -= num_of_escape;

  ret = (char *) malloc (len);

  i = 0;
  j = 0;
  while (arg[i] && (j < len-1))
    {
      if (arg[i] == '\\' && 
	  arg[ i + 1 ] && 
	  arg[ i + 1 ] == ',')
        ++i;

      ret[j++] = arg[i++];
    }

  ret[len-1] = '\0';

  return ret;
}

static const char *
get_multiple_arg_token_next(const char *arg)
{
  const char *tok;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
        }
      else
        break;
    }

  if (! tok || strlen(tok) == 1)
    return 0;

  return tok+1;
}

static int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc);

int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)
{
  int error = 0;

  if (option_given && (min > 0 || max > 0))
    {
      if (min > 0 && max > 0)
        {
          if (min == max)
            {
              /* specific occurrences */
              if (option_given != (unsigned int) min)
                {
                  fprintf (stderr, "%s: %s option occurrences must be %d\n",
                    prog_name, option_desc, min);
                  error = 1;
                }
            }
          else if (option_given < (unsigned int) min
                || option_given > (unsigned int) max)
            {
              /* range occurrences */
              fprintf (stderr, "%s: %s option occurrences must be between %d and %d\n",
                prog_name, option_desc, min, max);
              error = 1;
            }
        }
      else if (min > 0)
        {
          /* at least check */
          if (option_given < min)
            {
              fprintf (stderr, "%s: %s option occurrences must be at least %d\n",
                prog_name, option_desc, min);
              error = 1;
            }
        }
      else if (max > 0)
        {
          /* at most check */
          if (option_given > max)
            {
              fprintf (stderr, "%s: %s option occurrences must be at most %d\n",
                prog_name, option_desc, max);
              error = 1;
            }
        }
    }
    
  return error;
}
int
gmt_cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return gmt_cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
gmt_cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct gmt_cmdline_parser_params *params)
{
  int result;
  result = gmt_cmdline_parser_internal (argc, argv, args_info, params, 0);

  return result;
}

int
gmt_cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct gmt_cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = gmt_cmdline_parser_internal (argc, argv, args_info, &params, 0);

  return result;
}

int
gmt_cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (gmt_cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  return result;
}

int
gmt_cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (! args_info->cpt_file_given)
    {
      fprintf (stderr, "%s: '--cpt-file' ('-C') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (! args_info->proj_given)
    {
      fprintf (stderr, "%s: '--proj' ('-J') option required%s\n", prog_name, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (check_multiple_option_occurrences(prog_name, args_info->data_type_given, args_info->data_type_min, args_info->data_type_max, "'--data-type' ('-f')"))
     error = 1;
  
  
  /* checks for dependences among options */

  return error;
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see gmt_cmdline_parser_params.check_ambiguity
 * @param override @see gmt_cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               gmt_cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}

/**
 * @brief store information about a multiple option in a temporary list
 * @param list where to (temporarily) store multiple options
 */
static
int update_multiple_arg_temp(struct generic_list **list,
               unsigned int *prev_given, const char *val,
               const char *possible_values[], const char *default_value,
               gmt_cmdline_parser_arg_type arg_type,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  /* store single arguments */
  char *multi_token;
  const char *multi_next;

  if (arg_type == ARG_NO) {
    (*prev_given)++;
    return 0; /* OK */
  }

  multi_token = get_multiple_arg_token(val);
  multi_next = get_multiple_arg_token_next (val);

  while (1)
    {
      add_node (list);
      if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0,
          prev_given, multi_token, possible_values, default_value, 
          arg_type, 0, 1, 1, 1, long_opt, short_opt, additional_error)) {
        if (multi_token) free(multi_token);
        return 1; /* failure */
      }

      if (multi_next)
        {
          multi_token = get_multiple_arg_token(multi_next);
          multi_next = get_multiple_arg_token_next (multi_next);
        }
      else
        break;
    }

  return 0; /* OK */
}

/**
 * @brief free the passed list (including possible string argument)
 */
static
void free_list(struct generic_list *list, short string_arg)
{
  if (list) {
    struct generic_list *tmp;
    while (list)
      {
        tmp = list;
        if (string_arg && list->arg.string_arg)
          free (list->arg.string_arg);
        if (list->orig)
          free (list->orig);
        list = list->next;
        free (tmp);
      }
  }
}

/**
 * @brief updates a multiple option starting from the passed list
 */
static
void update_multiple_arg(void *field, char ***orig_field,
               unsigned int field_given, unsigned int prev_given, union generic_value *default_value,
               gmt_cmdline_parser_arg_type arg_type,
               struct generic_list *list)
{
  int i;
  struct generic_list *tmp;

  if (prev_given && list) {
    *orig_field = (char **) realloc (*orig_field, (field_given + prev_given) * sizeof (char *));

    switch(arg_type) {
    case ARG_INT:
      *((int **)field) = (int *)realloc (*((int **)field), (field_given + prev_given) * sizeof (int)); break;
    case ARG_STRING:
      *((char ***)field) = (char **)realloc (*((char ***)field), (field_given + prev_given) * sizeof (char *)); break;
    default:
      break;
    };
    
    for (i = (prev_given - 1); i >= 0; --i)
      {
        tmp = list;
        
        switch(arg_type) {
        case ARG_INT:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_STRING:
          (*((char ***)field))[i + field_given] = tmp->arg.string_arg; break;
        default:
          break;
        }        
        (*orig_field) [i + field_given] = list->orig;
        list = list->next;
        free (tmp);
      }
  } else { /* set the default value */
    if (default_value && ! field_given) {
      switch(arg_type) {
      case ARG_INT:
        if (! *((int **)field)) {
          *((int **)field) = (int *)malloc (sizeof (int));
          (*((int **)field))[0] = default_value->int_arg; 
        }
        break;
      case ARG_STRING:
        if (! *((char ***)field)) {
          *((char ***)field) = (char **)malloc (sizeof (char *));
          (*((char ***)field))[0] = gengetopt_strdup(default_value->string_arg);
        }
        break;
      default: break;
      }
      if (!(*orig_field)) {
        *orig_field = (char **) malloc (sizeof (char *));
        (*orig_field)[0] = 0;
      }
    }
  }
}

int
gmt_cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct gmt_cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  struct generic_list * data_type_list = NULL;
  int error = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    gmt_cmdline_parser_init (args_info);

  gmt_cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "cpt-file",	1, NULL, 'C' },
        { "proj",	2, NULL, 'J' },
        { "boundary",	1, NULL, 'B' },
        { "intens-file",	1, NULL, 'I' },
        { "more",	0, NULL, 'K' },
        { "over",	0, NULL, 'O' },
        { "portrait",	0, NULL, 'P' },
        { "region",	2, NULL, 'R' },
        { "time",	2, NULL, 'U' },
        { "verbose",	2, NULL, 'V' },
        { "shift-x",	2, NULL, 'X' },
        { "shift-y",	2, NULL, 'Y' },
        { "copies",	2, NULL, 'c' },
        { "data-type",	2, NULL, 'f' },
        { "header",	2, NULL, 'h' },
        { "swap",	2, NULL, '/' },
        { "output",	1, NULL, 0 },
        { "help",	0, NULL, '?' },
        { "full-help",	0, NULL, 0 },
        { "detailed-help",	0, NULL, '^' },
        { "version",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      c = getopt_long (argc, argv, "C:J::B:I:KOPR::U::V::X::Y::c::f::h::/::?^", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'C':	/* Color palette file to convert z to rgb.  */
        
        
          if (update_arg( (void *)&(args_info->cpt_file_arg), 
               &(args_info->cpt_file_orig), &(args_info->cpt_file_given),
              &(local_args_info.cpt_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "cpt-file", 'C',
              additional_error))
            goto failure;
        
          break;
        case 'J':	/* Select map proJection.  */
        
        
          if (update_arg( (void *)&(args_info->proj_arg), 
               &(args_info->proj_orig), &(args_info->proj_given),
              &(local_args_info.proj_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "proj", 'J',
              additional_error))
            goto failure;
        
          break;
        case 'B':	/* Basemap boundary annotation attributes.  */
        
        
          if (update_arg( (void *)&(args_info->boundary_arg), 
               &(args_info->boundary_orig), &(args_info->boundary_given),
              &(local_args_info.boundary_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "boundary", 'B',
              additional_error))
            goto failure;
        
          break;
        case 'I':	/* Use illumination. Give name of intensity grid file.  */
        
        
          if (update_arg( (void *)&(args_info->intens_file_arg), 
               &(args_info->intens_file_orig), &(args_info->intens_file_given),
              &(local_args_info.intens_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "intens-file", 'I',
              additional_error))
            goto failure;
        
          break;
        case 'K':	/* Allow for more plot code to be appended later.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->more_given),
              &(local_args_info.more_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "more", 'K',
              additional_error))
            goto failure;
        
          break;
        case 'O':	/* Set Overlay plot mode, i.e., append to an existing plot.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->over_given),
              &(local_args_info.over_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "over", 'O',
              additional_error))
            goto failure;
        
          break;
        case 'P':	/* Set Portrait page orientation.  */
        
        
          if (update_arg((void *)&(args_info->portrait_flag), 0, &(args_info->portrait_given),
              &(local_args_info.portrait_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "portrait", 'P',
              additional_error))
            goto failure;
        
          break;
        case 'R':	/* Specify the min/max coordinates of data region in user units.  */
        
        
          if (update_arg( (void *)&(args_info->region_arg), 
               &(args_info->region_orig), &(args_info->region_given),
              &(local_args_info.region_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "region", 'R',
              additional_error))
            goto failure;
        
          break;
        case 'U':	/* Plot Unix System Time stamp [and optionally appended text].  */
        
        
          if (update_arg( (void *)&(args_info->time_arg), 
               &(args_info->time_orig), &(args_info->time_given),
              &(local_args_info.time_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "time", 'U',
              additional_error))
            goto failure;
        
          break;
        case 'V':	/* Change the verbosity level.  */
        
        
          if (update_arg( (void *)&(args_info->verbose_arg), 
               &(args_info->verbose_orig), &(args_info->verbose_given),
              &(local_args_info.verbose_given), optarg, 0, "1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "verbose", 'V',
              additional_error))
            goto failure;
        
          break;
        case 'X':	/* X-shift origin of plot.  */
        
        
          if (update_arg( (void *)&(args_info->shift_x_arg), 
               &(args_info->shift_x_orig), &(args_info->shift_x_given),
              &(local_args_info.shift_x_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "shift-x", 'X',
              additional_error))
            goto failure;
        
          break;
        case 'Y':	/* Y-shift origin of plot.  */
        
        
          if (update_arg( (void *)&(args_info->shift_y_arg), 
               &(args_info->shift_y_orig), &(args_info->shift_y_given),
              &(local_args_info.shift_y_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "shift-y", 'Y',
              additional_error))
            goto failure;
        
          break;
        case 'c':	/* Specify the number of copies.  */
        
        
          if (update_arg( (void *)&(args_info->copies_arg), 
               &(args_info->copies_orig), &(args_info->copies_given),
              &(local_args_info.copies_given), optarg, 0, "1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "copies", 'c',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* Special formatting of input/output columns (time or geographical).  */
        
          if (update_multiple_arg_temp(&data_type_list, 
              &(local_args_info.data_type_given), optarg, 0, 0, ARG_STRING,
              "data-type", 'f',
              additional_error))
            goto failure;
        
          break;
        case 'h':	/* Input file has header records.  */
        
        
          if (update_arg( (void *)&(args_info->header_arg), 
               &(args_info->header_orig), &(args_info->header_given),
              &(local_args_info.header_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "header", 'h',
              additional_error))
            goto failure;
        
          break;
        case '/':	/* Swap 1st and 2nd column on input and/or output.  */
        
        
          if (update_arg( (void *)&(args_info->swap_arg), 
               &(args_info->swap_orig), &(args_info->swap_given),
              &(local_args_info.swap_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "swap", '/',
              additional_error))
            goto failure;
        
          break;
        case '?':	/* Show help (required arguments only), and exit.  */
        
          if (optopt) /* '?' represents an unrecognized option */
            goto failure;
        
        
          if (update_arg( 0 , 
               0 , &(args_info->help_given),
              &(local_args_info.help_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "help", '?',
              additional_error))
            goto failure;
        
          break;
        case '^':	/* Show help, including all details and hidden options, and exit.  */
        
        
          if (update_arg( 0 , 
               0 , &(args_info->detailed_help_given),
              &(local_args_info.detailed_help_given), optarg, 0, 0, ARG_NO,
              check_ambiguity, override, 0, 0,
              "detailed-help", '^',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* Output file  (default=`stdout').  */
          if (strcmp (long_options[option_index].name, "output") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->output_arg), 
                 &(args_info->output_orig), &(args_info->output_given),
                &(local_args_info.output_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "output", '-',
                additional_error))
              goto failure;
          
          }
          /* Show help, including hidden options, and exit.  */
          else if (strcmp (long_options[option_index].name, "full-help") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->full_help_given),
                &(local_args_info.full_help_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "full-help", '-',
                additional_error))
              goto failure;
          
          }
          /* Print version and exit.  */
          else if (strcmp (long_options[option_index].name, "version") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->version_given),
                &(local_args_info.version_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "version", '-',
                additional_error))
              goto failure;
          
          }
          
          break;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", GMT_CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */


  update_multiple_arg((void *)&(args_info->data_type_arg),
    &(args_info->data_type_orig), args_info->data_type_given,
    local_args_info.data_type_given, 0,
    ARG_STRING, data_type_list);

  args_info->data_type_given += local_args_info.data_type_given;
  local_args_info.data_type_given = 0;
  
  if (check_required)
    {
      error += gmt_cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  gmt_cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  free_list (data_type_list, 1 );
  
  gmt_cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
