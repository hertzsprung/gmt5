%-------------------------------------------------------------------------------------------
%	$Id: PSL_text.ps,v 1.3 2004-05-28 08:20:29 pwessel Exp $
%
%	P. Wessel, version 1
%	Text justification for paragraphs.
%	Kept as separate file until stable.
%	Knows about flush l,c,r and justified.
%	Knows about all GMT @ escapes, composites,
%	and underlining. No hypenation.  1 page only.
%-------------------------------------------------------------------------------------------

/PSL_setfont {	% Set Font, size, and color if needed
  /f exch def % Gets word flag from stack
  /k1 exch def % Gets word index from stack
  /fs PSL_size k1 get def	% Get font size
  /fn PSL_fnt k1 get def	% Get font
  fn PSL_lastfn eq fs PSL_lastfs eq and not {
    fs PSL_fontname fn get Y	% Set font and size
    /PSL_lastfn fn def
    /PSL_lastfs fs def
  } if
  /fc PSL_color k1 get def
  fc PSL_lastfc ne {
    /PSL_c fc 3 mul def
    0 1 2 {PSL_c add PSL_rgb exch get} for C	% Get and set color
    /PSL_lastfc fc def
  } if
  f 32 and 32 eq { % Underline
    /PSL_UL fs 0.075 mul def
    fs 0.025 mul W
    /PSL_show {PSL_ushow} def
  }
  {
    /PSL_show {ashow} def
  } ifelse
} bind def

/PSL_setfont2 {	% Only set font and size
  /f exch def % Gets word flag from stack
  /k1 exch def % Gets word index from stack
  /fs PSL_size k1 get def	% Get font size
  /fn PSL_fnt k1 get def	% Get font
  fn PSL_lastfn eq fs PSL_lastfs eq and not {
    fs PSL_fontname fn get Y	% Set font and size
    /PSL_lastfn fn def
    /PSL_lastfs fs def
  } if
} bind def

/PSL_wordheight {	% Gets word from stack, and calculates any adjustment to box height
  0 0 moveto false charpath flattenpath pathbbox /up exch def pop /down exch def pop newpath
  down PSL_ymin lt {/PSL_ymin down def} if
  up PSL_ymax gt {/PSL_ymax up def} if
} bind def

/PSL_ushow {
  currentpoint /y0 exch def /x0 exch def
  ashow
  currentpoint pop /x1 exch def
  x0 y0 PSL_UL sub m x1 y0 PSL_UL sub L S
  x1 y0 m
} bind def

/PSL_placeword {

  % Set font, size, and color.  Adjust baseline if needed. Place space and word

  /k exch def % Gets word index from stack
  /flag PSL_flag k get def
  k flag PSL_setfont

  /sshow {ashow} def
  PSL_col 0 eq {		% First word on a line
    /PSL_t 0 def			% 0 spaces before this word
    flag 4 and 4 eq {	% Must skip one TAB
      pr_char 0 (    ) ashow
    } if
  }
  {				% Need to find spaces before this word
    /f PSL_flag k 1 sub get def	% f is flag for previous word
    /PSL_t f 3 and def		% PSL_t is index into PSL_spaces and PSL_spacewidths for previous word
    f 32 and 32 eq flag 32 and 32 eq and {/sshow {PSL_ushow} def} if
  } ifelse

  /thisword_bshift PSL_bshift k get def	% The baseline shift
  thisword_bshift 0.0 ne {		% Shift baseline
    0 thisword_bshift G
  } if
  flag 8 and 8 eq {	% First composite char
    pr_char 0 PSL_spaces PSL_t get sshow
    k PSL_composite
  } if
  flag 24 and 0 eq {	% Anything but composite chars
    pr_char 0 PSL_spaces PSL_t get sshow pr_char 0 PSL_word k get PSL_show
    PSL_width k get 0 gt {/PSL_col PSL_col 1 add def} if
  } if
  thisword_bshift 0.0 ne {	% Shift baseline
    0 thisword_bshift neg G
  } if
} bind def

/PSL_composite {	% Place a composite character
  /k1 exch def % Get word index from stack
  /k2 k1 1 add def
  /char1 PSL_word k1 get def
  /char2 PSL_word k2 get def
  /w1 char1 stringwidth pop def
  /w2 char2 stringwidth pop def
  /delta w1 w2 sub 0.5 mul PSL_scale mul def
  delta 0.0 gt {
    /dx1 0 def
    /dx2 delta def
  }
  {
    /dx1 delta neg def
    /dx2 0 def
  } ifelse
  dx1 0 G currentpoint
  pr_char 0 char1 PSL_show moveto
  delta 0 G
  pr_char 0 char2 ashow
  dx2 0 G
} bind def

% Determine how much to expand text and also justify left/center/right

/PSL_expand {
  /k1 exch def % Get word index from stack
  /extra PSL_parwidth previous_linewidth sub comp_width add def
  PSL_CRLF k1 PSL_n1 eq or {/spread 0 def} {/spread extra def} ifelse
  /PSL_scale previous_linewidth 0.0 gt {PSL_parwidth previous_linewidth div} {1.0} ifelse def
  /ndiv lsum ncomp sub def
  ndiv 0 eq {/ndiv 1 def} if
  PSL_parjust 4 eq {/pr_char spread ndiv div def} {/pr_char 0 def} ifelse
  PSL_parjust 2 eq {extra 0.5 mul 0 rmoveto} if
  PSL_parjust 3 eq {extra 0 rmoveto} if
  /PSL_col 0 def
} bind def

% Calculate text paragraph height:

/PSL_textjustifier {
  /PSL_mode exch def	% From stack. 0 -> calculate height, no text is placed, 1 -> place text
  /PSL_col 0 def
  /PSL_ybase 0 def
  /PSL_parheight 0 def
  /PSL_ymin 0 def
  /PSL_ymax 0 def
  /PSL_top 0 def
  /PSL_bottom 0 def
  /last_font PSL_fnt 0 get def		% The previous font number
  /last_size PSL_size 0 get def		% The previous font size
  /last_color PSL_color 0 get def	% The previous color index
  /previous_linewidth 0 def
  /stop 0 def
  /start 0 def
  /lsum 0 def
  /line 0 def
  /ncomp 0 def
  /comp_width 0 def

  0 1 PSL_n1 {		% Loop over all the words

    /i exch def		% The current loop index
    /thisflag PSL_flag i get def					% # of space chars to follow this word
    i 0 eq {
      /PSL_t 0 def
      /lastflag 0 def
    }
    {
      /lastflag PSL_flag i 1 sub get def
      /PSL_t lastflag 3 and def
    } ifelse
    % PSL_t is index into PSL_spaces and PSL_spacewidths
    i thisflag PSL_setfont2							% Get and set font and size
    /thisword_width PSL_width i get def
    /comp_add 0 def
    /compw_add 0 def
    /PSL_tabwidth (    ) stringwidth pop def					% Get width of the TAB
    /PSL_spacewidths PSL_spaces {stringwidth pop} forall 3 array astore def	% and the spaces
    /ccount PSL_count i get def								% # of characters in this word
    thisflag 4 and 4 eq {	% Had leading tab
      /thisword_width thisword_width PSL_tabwidth add def
      /ccount ccount 4 add def
    } if
    lastflag 8 and 8 eq {/PSL_t 0 def /comp_add 1 def /compw_add thisword_width def} if
    /new_linewidth previous_linewidth thisword_width add PSL_spacewidths PSL_t get add def	% Width of line if word added

    /PSL_CRLF thisword_width 0.0 eq thisflag 16 and 0 eq and def
    /special thisflag 16 and 16 eq {true} {thisword_width 0.0 gt} ifelse def
    new_linewidth PSL_parwidth le special and
    {
      % Word will fit on current line
      PSL_col 0 eq {
        /PSL_ymin 0 def
        /PSL_ymax 0 def
      } if
      /stop stop 1 add def			% Include this word
      /PSL_col PSL_col 1 add def		% Column place of next word
      /previous_linewidth new_linewidth def	% Update the unadjusted line width
      /lsum lsum ccount add PSL_t add def	% Update character count
      /ncomp ncomp comp_add add def
      /comp_width comp_width compw_add add def

    }
    {
      % Must process current line and move to next

      1 PSL_mode eq {		% Write out the first word on this line

	% Determine how much to expand text and also justify left/center/right

        start PSL_expand

	start PSL_placeword

      }
      {
        PSL_word start get PSL_wordheight
      } ifelse

      /last stop 1 sub def
      /start start 1 add def

      1 PSL_mode eq {		% Write out the remaining words on this line
        start 1 last {PSL_placeword} for
      }
      {
        start 1 last {PSL_word exch get PSL_wordheight} for
        line 0 eq {	% First outputline
          /PSL_top PSL_ymax def
        } if
      } ifelse

      /start stop def
      /PSL_ybase PSL_ybase PSL_linespace sub def
      1 PSL_mode eq {0 PSL_ybase moveto} if	% CR/LF
      /stop stop 1 add def				% Include this word
      /previous_linewidth thisword_width def
      /lsum ccount def
      /ncomp comp_add def
      /comp_width compw_add def
      /PSL_col 0 def
      /line line 1 add def
    } ifelse
  } for

  /last stop 1 sub def
  last PSL_n lt {	% One or more words left hanging on last line

    /PSL_CRLF true def
    1 PSL_mode eq {

      % Determine how much to expand text and also justify left/center/right

      start PSL_expand

      start PSL_placeword

      /start start 1 add def
      start 1 last {PSL_placeword} for

    }
    {
      /PSL_ymin 0 def
      PSL_word start get PSL_wordheight
      /start start 1 add def
      start 1 last {PSL_word exch get PSL_wordheight} for
      line 0 eq {	% First outputline
        /PSL_top PSL_ymax def
      } if
    } ifelse
  } if
  /PSL_bottom PSL_ymin def
  /PSL_parheight PSL_ybase neg PSL_top add PSL_bottom sub def
} def % PSL_textjustifier

% Cookbook Example Program from First Printing, Revised 7 Jan 1985
% Program: Placing Text Along an Arbitrary Path     Number: 17
% Modified for use in GMT's pslib.
%-----------------------------------------------------------------------------
%
/PSL_pathtextdict 26 dict def			% Local storage for the procedure PSL_pathtext.
							   
/PSL_pathtext					% PSL_pathtext'' will place a string
  { PSL_pathtextdict begin			% of text along any path. It takes
    /textheight exch def                          % a string and starting offset
    /just exch def                          % a string and starting offset
    /offset exch def				% a string and starting offset
    /str exch def				% distance from the beginning of
						% the path as its arguments. Note
						% that PSL_pathtext assumes that a
						% path has already been defined
						% and after it places the text
						% along the path, it clears the
						% current path like the ``stroke''
						% and ``fill'' operators; it also
						% assumes that a font has been
						% set. ``pathtext'' begins placing
						% the characters along the current
						% path, starting at the offset
						% distance and continuing until
						% either the path length is
						% exhausted or the entire string
						% has been printed, whichever
						% occurs first. The results will
						% be more effective when a small
						% point size font is used with
						% sharp curves in the path.
								       
    /pathdist 0 def				% Initialize the distance we have
						% travelled along the path.
    /setdist offset def				% Initialize the distance we have
						% covered by setting characters.
    /charcount 0 def				% Initialize the character count.
    /justx just 4 mod 2 sub 2 div def
    /justy just 4 idiv 2 sub textheight mul 2 div def
    gsave
      flattenpath				% Reduce the path to a series of
						% straight line segments. The
						% characters will be placed along
						% the line segments in the
						% ``linetoproc.''
      {movetoproc} {linetoproc}			% The basic strategy is to process
	{curvetoproc} {closepathproc}		% the segments of the path,
	pathforall				% keeping a running total of the
						% distance we have travelled so
						% far (pathdist). We also keep
						% track of the distance taken up
						% by the characters that have been
						% set so far (setdist). When the
						% distance we have travelled along
						% the path is greater than the
						% distance taken up by the set
						% characters, we are ready to set
						% the next character (if there are
						% any left to be set). This
						% process continues until we have
						% exhausted the full length of the
						% path.
    grestore
    newpath					% Clear the current path.
    end
  } def
       
PSL_pathtextdict begin
/movetoproc					% ``movetoproc'' is executed when
  { /newy exch def /newx exch def		% a moveto component has been
						% encountered in the pathforall
						% operation.
    /firstx newx def /firsty newy def		% Remember the ``first point'' in
						% the path so that when we get a
						% ``closepath'' component we can
						% properly handle the text.
    /ovr 0 def
    newx newy transform
    /cpy exch def /cpx exch def			% Explicitly keep track of the
						% current position in device
						% space.
  } def
       
/linetoproc					% ``linetoproc'' is executed when
						% a lineto component has been
						% encountered in the pathforall
						% operation.
  { /oldx newx def /oldy newy def		% Update the old point.
    /newy exch def /newx exch def		% Get the new point.
    /dx newx oldx sub def
    /dy newy oldy sub def
    /dist dx dup mul dy dup mul add		% Calculate the distance between
						% the old and the new point.
      sqrt def
    /dsx dx dist div ovr mul def		% dsx and dsy are used to update
    /dsy dy dist div ovr mul def		% the current position to be just
						% beyond the width of the previous
						% character.
    oldx dsx add oldy dsy add transform
    /cpy exch def /cpx exch def			% Update the current position.
    /pathdist pathdist dist add def		% Increment the distance we have
						% travelled along the path.
    { setdist pathdist le			% Keep setting characters along
						% this path segment until we have
						% exhausted its length.
	{ charcount str length lt		% As long as there are still
	    {setchar} {exit} ifelse }		% characters left in the string,
						% set them.
	{ /ovr setdist pathdist sub def		% Keep track of how much we have
	  exit }				% overshot the path segment by
	ifelse					% setting the previous character.
						% This enables us to position the
						% origin of the following
						% characters properly on the path.
    } loop
  } def
       
/curvetoproc					% ``curvetoproc'' is executed when
  { (ERROR: No curveto's after flattenpath!)	% a curveto component has been
    print					% encountered in the pathforall
  } def						% operation. It prints an error
						% message since there shouldn't be
						% any curveto's in a path after
						% the flattenpath operator has
						% been executed.
							    
/closepathproc					% ``closepathproc'' is executed
  { firstx firsty linetoproc			% when a closepath component has
    firstx firsty movetoproc			% been encountered in the
  } def						% pathforall operation. It
						% simulates the action of the
						% operator ``closepath'' by
						% executing ``linetoproc'' with
						% the coordinates of the most
						% recent ``moveto'' and then
						% executing ``movetoproc'' to the
						% same point.
							 
/setchar					% ``setchar'' sets the next
  { /char str charcount 1 getinterval def	% character in the string along
						% the path and then updates the
						% amount of path we have
						% exhausted.
    /charcount charcount 1 add def		% Increment the character count.
    /charwidth char stringwidth pop def		% Find the width of the character.
    gsave
      cpx cpy itransform translate		% Translate to the current
						% position in user space.
      dy dx atan rotate				% Rotate the x-axis to coincide
						% with the current segment.
      0 justy moveto
      char show
      0 justy neg rmoveto
      currentpoint transform
      /cpy exch def /cpx exch def		% Update the current position
    grestore					% before we restore ourselves to
						% the untransformed state.
    /setdist setdist charwidth add def		% Increment the distance we have
  } def						% covered by setting characters.
end

%%%%%%% NEW STUFF %%%%%%%%%%%%%%

% Function for placing m curved textlabels along a line of n points
% Assumes the following variables have been assigned already:
% PSL_n		Number of points in the path
% PSL_x		(x,y) coordinates of the path
% PSL_y
% PSL_m		Number of labels
% PSL_str	Array with all the labels
% PSL_node	Array with (x,y) node number of label position
% PSL_setpenrgb Function that sets the pen rgb
% PSL_settxtrgb	Function that sets the font rgb
%
% We use the current pen texture and width

/PSL_labelline {
  /PSL_n1 PSL_n 1 sub def	% one less is the upper limit in for loops
  /PSL_m1 PSL_m 1 sub def	% same
  
  % Calculate the width of each label string
  /PSL_width PSL_n array def	% Assign space for distance
  0 1 PSL_m1 {
    /i exch def
    PSL_width i PSL_txt i get stringwidth pop put
  } for
  
  % Calculate along-track distances
  /PSL_newx PSL_x 0 get def
  /PSL_newy PSL_y 0 get def
  /dist 0.0 def
  /PSL_dist PSL_n array def	% Assign space for distance
  PSL_dist 0 dist put		% Distances start at 0 and the 'th point
  1 1 PSL_n1 {			% Loop over the remaining points
    /i exch def
    /PSL_oldx PSL_newx def
    /PSL_oldy PSL_newy def
    /PSL_newx PSL_x i get def
    /PSL_newy PSL_y i get def
    /dx PSL_newx PSL_oldx sub def
    /dy PSL_newy PSL_oldy sub def
    /dist dist dx dx mul dy dy mul add sqrt add def
    PSL_dist i dist put
  } for
  
  % Initialize an array with all the original line points plus the set of 2*m
  % points at the transition from line to labelspace at each label
  % At the end of this section, the PSL_xx/yy array will be the array to use.
  
  /PSL_nn PSL_n PSL_m 2 mul add def	% The total path will be 2*m points longer
  /PSL_xx PSL_nn array def		% Assign space for x and y
  /PSL_yy PSL_nn array def
  /k 0 def				% Current cut point
  /PSL_nc PSL_m 2 mul 1 add def		% 2*m points + one last acting as infinity
  /PSL_cuts PSL_nc array def		% The array of distances to each cut
  /PSL_nc1 PSL_nc 1 sub def		% One less to use in for loop limits
  0 1 PSL_m1 {				% For each of the m labels
    /i exch def						% Index for label distance
    /dist PSL_dist PSL_node i get get def		% Recall the distance to this label center
    /halfwidth PSL_width i get 2 div PSL_gap add def	% Set the halfwidth + gap distance
    PSL_cuts k dist halfwidth sub put			% Distance at beginning of label gap
    /k k 1 add def					% Was at start, now go to end distance node
    PSL_cuts k dist halfwidth add put			% Distance at the end of label gap
    /k k 1 add def					% Was at end, move to next
  } for
  PSL_cuts k 100000.0 put				% Last cut has "infinite" distance

  /j 0 def				% Index for new track array
  /i 0 def				% Index for old track array
  /k 0 def				% Index for current cut distance
  /dist 0.0 def				% Current distance along track, starting at zero
  /kind PSL_nn array def		% 0 = ordinary point, 1 = added point for label gap
  0 1 PSL_n1 {				% Loop over every original line point
    /i exch def				% Index into current point on original line xy array
    /last_dist dist def			% Update distance to last point (initially zero)
    /dist PSL_dist i get def		% Distance to current point
    k 1 PSL_nc1 {			% Loop over remaining cuts (starting with all)
      /kk exch def			% Index into current cut distance
      /this_cut PSL_cuts kk get def	% Distance to start of this label gap
      dist this_cut gt {		% Oh, oh, we just stepped over a cut point
        /f dist this_cut sub dist last_dist sub div def			% Get fractional distance
        PSL_xx j PSL_x i get dup PSL_x i 1 sub get sub f mul sub put	% Calc (x,y) at label start (or stop) point
        PSL_yy j PSL_y i get dup PSL_y i 1 sub get sub f mul sub put
        kind j 1 put			% Set kind to 1 since it is an added cut point
        /j j 1 add def			% Go to next output point
        /k k 1 add def			% Done with this cut point
      } if
    } for
    dist PSL_cuts k get lt {		% Having dealt with the cut, we may add the regular point
      PSL_xx j PSL_x i get put
      PSL_yy j PSL_y i get put
      kind j 0 put			% Ordinary (original) coordinates
      /j j 1 add def			% Go to next output point
    } if
  } for

% Now we have the final x/y array and we are ready to simply lay down the lines
% and place the text along the line where there are labels.  We will recycle the
% original PSL_x/y arrays to store the output points since it is possible that
% we will need to reverse a path so that the text is upside-up.

  newpath PSL_setpenrgb			% Initialize new path and set line color
  /PSL_nn1 PSL_nn 1 sub def		% End index in for loop
  /n 0 def				% Toggle: o means line, 1 means text
  /k 0 def				% Index of the current text string
  PSL_x PSL_xx 0 get put		% Place first point in array
  PSL_y PSL_yy 0 get put
  /j 0 def				% Output point number counter
  1 1 PSL_nn1				% Loop over rest of points
  {
    /i exch def				% Index into PSL_xx/yy arrays
    /type kind i get def		% Check what kind of point the current point is
    PSL_x PSL_xx i get j put		% Add this point to the path
    PSL_y PSL_yy i get j put
    /j j 1 add def			% Update point count
    type 1 eq				% If this is a cut point we either stroke or place text
    {
      n 0 eq				% n is 0 so this is the strokable segment
      {
        PSL_x 0 get PSL_y 0 get moveto				% Set the anchor point of the path
	1 1 j { /i exch def PSL_x i get PSL_y i get lineto}	% Lay down the rest of the path
        stroke /n 1 def PSL_settxtrgb				% Stroke, set n to 1, and switch to font color
      }
      {					% here, n = 1 so this is the segment along which text should be placed
        PSL_x j get PSL_x 0 get lt	% Path must first be reversed to avoid upside-down text
	{
	  0 1 j 2 idiv			% Loop over half the path and swap left/right points
	  {
	    /left exch def		% Current left point
	    /right j left sub def	% Matching right point
	    /tmp PSL_x left get def	% Swap left and right values for x then y
	    PSL_x left PSL_x right get put
	    PSL_x right tmp put
	    /tmp PSL_y left get def
	    PSL_y left PSL_y right get put
	    PSL_y right tmp put
	  } for
	} if
	% Now PSL_x/y has the correct order to give proper text angles 
        PSL_txt k get PSL_gap PSL_just PSL_height PSL_pathtext	% Place the text
	/n 0 def /k k 1 add def PSL_setpenrgb			% Set n back to 0 and switch to pen color
      } ifelse
      newpath
      PSL_x PSL_xx i get 0 put
      PSL_y PSL_yy i get 0 put
      /j 0 def
    } if
  } for
  n 0 eq {stroke} {newpath} ifelse
} def
