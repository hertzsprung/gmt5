%-------------------------------------------------------------------------------------------
%	$Id: PSL_label.ps,v 1.2 2004-06-02 03:11:13 pwessel Exp $
%
%	P. Wessel, version 1
%
%	PS routines for handling contour labels and clipping of
%	contour lines going through labels.
%
%	There are two parts.  First is something straight out of
%	the Adobe Cookbook for placing text along a curved line.
%	The second part is the functions that assist in finding
%	out where labels are placed and setting clip paths etc.

% Cookbook Example Program from First Printing, Revised 7 Jan 1985
% Program: Placing Text Along an Arbitrary Path     Number: 17
% Modified for use in GMT's pslib.
%-----------------------------------------------------------------------------
%
/PSL_pathtextdict 26 dict def			% Local storage for the procedure PSL_pathtext.
							   
/PSL_pathtext					% PSL_pathtext'' will place a string
  { PSL_pathtextdict begin			% of text along any path. It takes
    /textheight exch def                          % a string and starting offset
    /just exch def                          % a string and starting offset
    /offset exch def				% a string and starting offset
    /str exch def				% distance from the beginning of
						% the path as its arguments. Note
						% that PSL_pathtext assumes that a
						% path has already been defined
						% and after it places the text
						% along the path, it clears the
						% current path like the ``stroke''
						% and ``fill'' operators; it also
						% assumes that a font has been
						% set. ``pathtext'' begins placing
						% the characters along the current
						% path, starting at the offset
						% distance and continuing until
						% either the path length is
						% exhausted or the entire string
						% has been printed, whichever
						% occurs first. The results will
						% be more effective when a small
						% point size font is used with
						% sharp curves in the path.
								       
    /pathdist 0 def				% Initialize the distance we have
						% travelled along the path.
    /setdist offset def				% Initialize the distance we have
						% covered by setting characters.
    /charcount 0 def				% Initialize the character count.
    /justx just 4 mod 2 sub 2 div def
    /justy just 4 idiv 2 sub textheight mul 2 div def
    gsave
      flattenpath				% Reduce the path to a series of
						% straight line segments. The
						% characters will be placed along
						% the line segments in the
						% ``linetoproc.''
      {movetoproc} {linetoproc}			% The basic strategy is to process
	{curvetoproc} {closepathproc}		% the segments of the path,
	pathforall				% keeping a running total of the
						% distance we have travelled so
						% far (pathdist). We also keep
						% track of the distance taken up
						% by the characters that have been
						% set so far (setdist). When the
						% distance we have travelled along
						% the path is greater than the
						% distance taken up by the set
						% characters, we are ready to set
						% the next character (if there are
						% any left to be set). This
						% process continues until we have
						% exhausted the full length of the
						% path.
    grestore
    newpath					% Clear the current path.
    end
  } def
       
PSL_pathtextdict begin
/movetoproc					% ``movetoproc'' is executed when
  { /newy exch def /newx exch def		% a moveto component has been
						% encountered in the pathforall
						% operation.
    /firstx newx def /firsty newy def		% Remember the ``first point'' in
						% the path so that when we get a
						% ``closepath'' component we can
						% properly handle the text.
    /ovr 0 def
    newx newy transform
    /cpy exch def /cpx exch def			% Explicitly keep track of the
						% current position in device
						% space.
  } def
       
/linetoproc					% ``linetoproc'' is executed when
						% a lineto component has been
						% encountered in the pathforall
						% operation.
  { /oldx newx def /oldy newy def		% Update the old point.
    /newy exch def /newx exch def		% Get the new point.
    /dx newx oldx sub def
    /dy newy oldy sub def
    /dist dx dup mul dy dup mul add sqrt def	% Calculate the distance between
						% the old and the new point.
    dist 0 ne
    {
      /dsx dx dist div ovr mul def		% dsx and dsy are used to update
      /dsy dy dist div ovr mul def		% the current position to be just
						% beyond the width of the previous
						% character.
      oldx dsx add oldy dsy add transform
      /cpy exch def /cpx exch def			% Update the current position.
      /pathdist pathdist dist add def		% Increment the distance we have
						% travelled along the path.
      { setdist pathdist le			% Keep setting characters along
						% this path segment until we have
						% exhausted its length.
	  { charcount str length lt		% As long as there are still
	      {setchar} {exit} ifelse }		% characters left in the string,
						% set them.
	  { /ovr setdist pathdist sub def		% Keep track of how much we have
	    exit }				% overshot the path segment by
	  ifelse					% setting the previous character.
						% This enables us to position the
						% origin of the following
						% characters properly on the path.
      } loop
    } if
  } def
       
/curvetoproc					% ``curvetoproc'' is executed when
  { (ERROR: No curveto's after flattenpath!)	% a curveto component has been
    print					% encountered in the pathforall
  } def						% operation. It prints an error
						% message since there shouldn't be
						% any curveto's in a path after
						% the flattenpath operator has
						% been executed.
							    
/closepathproc					% ``closepathproc'' is executed
  { firstx firsty linetoproc			% when a closepath component has
    firstx firsty movetoproc			% been encountered in the
  } def						% pathforall operation. It
						% simulates the action of the
						% operator ``closepath'' by
						% executing ``linetoproc'' with
						% the coordinates of the most
						% recent ``moveto'' and then
						% executing ``movetoproc'' to the
						% same point.
							 
/setchar					% ``setchar'' sets the next
  { /char str charcount 1 getinterval def	% character in the string along
						% the path and then updates the
						% amount of path we have
						% exhausted.
    /charcount charcount 1 add def		% Increment the character count.
    /charwidth char stringwidth pop def		% Find the width of the character.
    gsave
      cpx cpy itransform translate		% Translate to the current
						% position in user space.
      dy dx atan rotate				% Rotate the x-axis to coincide
						% with the current segment.
      0 justy moveto
      char show
      0 justy neg rmoveto
      currentpoint transform
      /cpy exch def /cpx exch def		% Update the current position
    grestore					% before we restore ourselves to
						% the untransformed state.
    /setdist setdist charwidth add def		% Increment the distance we have
  } def						% covered by setting characters.
end

%%%%%%% NEW STUFF %%%%%%%%%%%%%%

% Function for placing m curved textlabels along a line of n points
% Assumes the following variables have been assigned already:
% PSL_n		Number of points in the path
% PSL_x		(x,y) coordinates of the path
% PSL_y
% PSL_angle	The annotation angle
% PSL_m		Number of labels
% PSL_str	Array with all the labels
% PSL_node	Array with (x,y) node number of label position
% PSL_setpenrgb Function that sets the pen rgb
% PSL_settxtrgb	Function that sets the font rgb
%
% We use the current pen texture and width

/PSL_labelline
{
  /bits exch def				% 4 on/of bit settings as indicated below
  /PSL_labeltype bits 1 and def			% 0 for straight label, 1 for curved
  /PSL_placetext bits 2 and 0 eq def		% true to place text, false to just make space
  /PSL_strokeline bits 4 and 0 eq def		% true draws line, false skips
  /PSL_clippath bits 8 and 0 gt def		% false inacative, true creates clippath for labels
  /PSL_paintclippath bits 16 and 0 gt def	% false inacative, true paints clippath for debug
  /PSL_firstcall bits 64 and 0 gt def		% true first time called, false later
  /PSL_lastcall bits 128 and 0 gt def		% true last time called, false before
  /PSL_n1 PSL_n 1 sub def			% one less is the upper limit in for loops
  /PSL_m1 PSL_m 1 sub def			% same
  /PSL_justx PSL_just 4 mod 1 sub -0.5 mul def
  /PSL_justy PSL_just 4 idiv 2 sub PSL_height mul 2 div def
  /PSL_paintclippath PSL_paintclippath PSL_debug not and def	% painting means no debug

  PSL_calcwidth		% Calculate the width of each label string
  PSL_calcdist		% Calculate along-track distances
  PSL_addcutstopath	% Expand path to include the cut points

% Now we have the final xx/yy array and we are ready to simply lay down the lines
% and place the text along the line where there are labels.  We will use the
% new array PSL_xp/yp to store the final points prior to use

  PSL_clippath PSL_firstcall and	% Want clipping and it is the first time called
  {	
    gsave newpath			% Bracket with gsave and start clip path the first time - later we append
    PSL_debug not
    {					% Save status and get current clip path inherited from outside
      clippath
    } if
  } if
  PSL_setpenrgb				% Set line color
  /PSL_nn1 PSL_nn 1 sub def		% End index in for loop
  /n 0 def				% Toggle: o means line, 1 means text
  /k 0 def				% Index of the current text string
  /j 0 def				% Output point number counter
  /PSL_seg 0 def			% Line segment number
  /PSL_xp PSL_n array def
  /PSL_yp PSL_n array def
  PSL_xp 0 PSL_xx 0 get put		% Place first point in array
  PSL_yp 0 PSL_yy 0 get put
  1 1 PSL_nn1				% Loop over rest of points
  {
    /i exch def				% Index into PSL_xx/yy arrays
    /type PSL_kind i get def		% Check what kind of point the current point is
    /j j 1 add def			% Update point count
    PSL_xp j PSL_xx i get put		% Add this point to the path
    PSL_yp j PSL_yy i get put
    type 1 eq				% If this is a cut point we either stroke or place text
    {
      n 0 eq				% n is 0 so this is the strokable segment
      {
        PSL_drawline
      }
      {					% here, n = 1 so this is the segment along which text should be placed
	PSL_reversepath			% Reverse path if needed to place text correctly
        PSL_textline
      } ifelse
      /j 0 def
      PSL_xp j PSL_xx i get put		% Place new first point in array
      PSL_yp j PSL_yy i get put
    } if
  } for
  n 0 eq {PSL_drawline} if	% Finish off the last line segment
  
  PSL_lastcall			% After last call we execute the clip path
  {
    PSL_clippath 
    {
      PSL_debug
      {
        gsave 0.9 0.5 0.5 C fill grestore stroke
      }
      {
        clip
      } ifelse
      PSL_paintclippath		% Debug option to see the clip path
      {
        gsave
        clippath 0.75 setgray fill
        grestore
      } if
    } if
    newpath			% Clean up and return
  } if
} def

/PSL_textline
{
  PSL_placetext			% If we want to place the text
  {
    PSL_labeltype 0 eq		% Place straight text at the given angle
    {
      PSL_clippath
      {
        PSL_straightlabelclip
      }
      {
        PSL_straightlabel
      } ifelse
    }
    {				% Place curved text along the path just laid down
      PSL_clippath
      {
        PSL_curvedlabelclip
      }
      {
        PSL_curvedlabel
      } ifelse
    } ifelse
  } if
  /n 0 def /k k 1 add def PSL_setpenrgb			% Set n back to 0, goto next label, and switch to pen color
} def

/PSL_calcwidth			% Calculate the width of each label string
{
  /PSL_width PSL_m array def	% Assign space for distance
  0 1 PSL_m1
  {
    /i exch def
    PSL_width i PSL_str i get stringwidth pop put
  } for
} def

/PSL_calcdist			% Calculate the distance along the line
{
  /PSL_newx PSL_x 0 get def
  /PSL_newy PSL_y 0 get def
  /dist 0.0 def			% Cumulative distance at first point is 0
  /PSL_dist PSL_n array def	% Assign array space for distance
  PSL_dist 0 0.0 put		% Distances start at 0 and the 'th point
  1 1 PSL_n1			% Loop over the remaining points
  {
    /i exch def
    /PSL_oldx PSL_newx def
    /PSL_oldy PSL_newy def
    /PSL_newx PSL_x i get def
    /PSL_newy PSL_y i get def
    /dx PSL_newx PSL_oldx sub def
    /dy PSL_newy PSL_oldy sub def
    /dist dist dx dx mul dy dy mul add sqrt add def
    PSL_dist i dist put
  } for
} def

/PSL_addcutstopath
{
  % Initialize an array with all the original line points plus the set of 2*m
  % points at the transition from line to labelspace at each label
  % At the end of this section, the PSL_xx/yy array will be the array to use.
  
  /PSL_nn PSL_n PSL_m 2 mul add def	% The total path will be 2*m points longer
  /PSL_xx PSL_nn array def		% Assign new space for x and y
  /PSL_yy PSL_nn array def
  /k 0 def				% Current cut point
  /PSL_nc PSL_m 2 mul 1 add def		% 2*m points + one last acting as infinity
  /PSL_cuts PSL_nc array def		% The array of distances to each cut
  /PSL_nc1 PSL_nc 1 sub def		% One less to use in for loop limits
  0 1 PSL_m1				% For each of the m labels
  {
    /i exch def						% Index for label distance
    /dist PSL_dist PSL_node i get get def		% Recall the distance to this label center
    /halfwidth PSL_width i get 2 div PSL_gap_x add def	% Set the halfwidth + gap distance
    PSL_cuts k dist halfwidth sub put			% Distance at beginning of label gap
    /k k 1 add def					% Was at start, now go to end distance node
    PSL_cuts k dist halfwidth add put			% Distance at the end of label gap
    /k k 1 add def					% Was at end, move to next
  } for
  PSL_cuts k 100000.0 put				% Last cut has "infinite" distance

  /j 0 def				% Index for new track array
  /k 0 def				% Index for current cut distance
  /dist 0.0 def				% Current distance along track, starting at zero
  /PSL_kind PSL_nn array def		% 0 = ordinary point, 1 = added point for label gap
  0 1 PSL_n1				% Loop over every original line point
  {
    /i exch def				% Index into current point on original line xy array
    /last_dist dist def			% Update distance to last point (initially zero)
    /dist PSL_dist i get def		% Distance to current point
    k 1 PSL_nc1				% Loop over remaining cuts (starting with all)
    {
      /kk exch def			% Index into current cut distance
      /this_cut PSL_cuts kk get def	% Distance to start of this label gap
      dist this_cut gt			% Oh, oh, we just stepped over a cut point
      {
        /ds dist last_dist sub def		% Change in distance
        /f dist this_cut sub ds div def		% Get fractional change in distance
        PSL_xx j PSL_x i get dup PSL_x i 1 sub get sub f mul sub put	% Calc (x,y) at label start (or stop) point
        PSL_yy j PSL_y i get dup PSL_y i 1 sub get sub f mul sub put
        PSL_kind j 1 put		% Set PSL_kind to 1 since it is an added cut point
        /j j 1 add def			% Go to next output point
        /k k 1 add def			% Done with this cut point
      } if
    } for
    dist PSL_cuts k get le		% Having dealt with the cut, we may add the regular point
    {
      PSL_xx j PSL_x i get put
      PSL_yy j PSL_y i get put
      PSL_kind j 0 put			% Ordinary (original) coordinates
      /j j 1 add def			% Go to next output point
    } if
  } for
} def

/PSL_reversepath
{
  PSL_labeltype 1 eq PSL_xp j get PSL_xp 0 get lt and	% Path must first be reversed to avoid upside-down text
  {
    0 1 j 2 idiv			% Loop over half the path and swap left/right points
    {
      /left exch def		% Current left point
      /right j left sub def	% Matching right point
      /tmp PSL_xp left get def	% Swap left and right values for x then y
      PSL_xp left PSL_xp right get put
      PSL_xp right tmp put
      /tmp PSL_yp left get def
      PSL_yp left PSL_yp right get put
      PSL_yp right tmp put
    } for
  } if
  % Now PSL_xp/yp has the correct order to give proper text angles
} def

/PSL_straightlabel
{
  newpath				% Must clear off the invisible text path as it is not needed
  /node PSL_node k get 1 add k 2 mul add def		% Current index into angle array of extra length
  PSL_xx node get PSL_yy node get moveto		% Set text center point
  gsave							% Save because we are messing with rotations
  PSL_angle k get rotate				% Rotate the coordinate system to follow baseline text
  PSL_width k get PSL_justx mul PSL_justy rmoveto	% Adjust for justification
  PSL_str k get show					% Place text
  grestore						% Restore to system prior to rotation
} def

/PSL_curvedlabel
{ % Places the curved text label on current segment
  PSL_placeline PSL_str k get PSL_gap_x PSL_just PSL_height PSL_pathtext
} def

/PSL_straightlabelclip
{ % Lays down a rectangular clipbox for one label
  /node PSL_node k get 1 add k 2 mul add def		% Current index into angle array of extra length
  /xp PSL_xx node get def
  /yp PSL_yy node get def				% Get text placement point
  /MAT PSL_angle k get matrix rotate def		% Rotate the coordinate system to follow baseline text
  /W PSL_width k get PSL_gap_x 2 mul add def		% Width of current label space including clearance
  /H PSL_height PSL_gap_y 2 mul add def			% Height of current label space including clearance
  /x0 0 W PSL_justx mul add def				% (x0,y0) is the rotated and adjusted text LL point relative to xp,yp
  /y0 0 PSL_justy add PSL_gap_y sub def			%
  /DelX 0 W W 3 array astore def				% Offsets in x from LL
  /DelY H H 0 3 array astore def				% Offsets in y from LL
  x0 y0 MAT transform					% Get unrotated dx/dy
  /dy exch def /dx exch def
  xp dx add yp dy add moveto				% Lay down LL anchor point
  0 1 2
  { % Append lineto for the other 3 points
    /ii exch def
    x0 DelX ii get add y0 DelY ii get add MAT transform
    /dy exch def /dx exch def
    xp dx add yp dy add lineto				% Draw to next point
  } for
  closepath		% Explicitly close the path box
} def

/PSL_curvedlabelclip
{ % Lays down a curved clipbox for one label
  /H PSL_height 2 div PSL_gap_y add def
  /xoff j 1 add array def
  /yoff j 1 add array def
  0 1 j {	% Loop over points along line to calculate angle and offsets
    /ii exch def	% Index
    /x PSL_xp ii get def
    /y PSL_yp ii get def
    ii 0 eq {	% Are we at the first point and hence must calculate angle using 0 and 1?
      /x1 PSL_xp 1 get def
      /y1 PSL_yp 1 get def
      /dx x1 x sub def
      /dy y1 y sub def
    }
    {
      /i1 ii 1 sub def	% Previous point
      /x1 PSL_xp i1 get def
      /y1 PSL_yp i1 get def
      /dx x x1 sub def
      /dy y y1 sub def
    } ifelse
    dx 0.0 ne dy 0.0 ne and
    {	% Only calculate new angle if not duplicates
      /angle dy dx atan 90 add def
      /s angle sin def
      /c angle cos def
    } if
    xoff ii H c mul put
    yoff ii H s mul put
  } for
  
  % Lay down next clip segment

  %PSL_debug { newpath } if
  PSL_xp 0 get xoff 0 get add PSL_yp 0 get yoff 0 get add moveto
  1 1 j {	% Loop over the rest of the upper line
    /ii exch def
    PSL_xp ii get xoff ii get add PSL_yp ii get yoff ii get add lineto
  } for
  j -1 0 {	% Loop backwards over the rest of the lower line
    /ii exch def
    PSL_xp ii get xoff ii get sub PSL_yp ii get yoff ii get sub lineto
  } for
  closepath
  %PSL_debug { gsave 0.9 0.5 0.5 C fill grestore stroke} if
} def

/PSL_placeclippath
{
  PSL_clippath					% Now lay down the clippath
  {
    0 1 PSL_m1
    {
      /k exch def		% Current label number
      /i k 5 mul def		% Start of the label path
      PSL_clipx i get PSL_clipy i get moveto
      1 1 4
      {
	/j exch i add def
	PSL_clipx j get PSL_clipy j get lineto
      } for
    } for
    PSL_debug not { clip } if
  } if
} def

/PSL_drawline
{
  /str 20 string def
  % PSL_strokeline PSL_seg 0 eq and			% If we asked to draw lines...
  PSL_strokeline 			% If we asked to draw lines...
  {
    PSL_placeline stroke				% Lay down the rest of the path and stroke it
  } if
  /PSL_seg PSL_seg 1 add def				% Goto next segment number
  /n 1 def PSL_settxtrgb				% Set n to 1, and switch to font color
} def

/PSL_placeline
{
  PSL_xp 0 get PSL_yp 0 get moveto				% Set the anchor point of the path
  1 1 j { /ii exch def PSL_xp ii get PSL_yp ii get lineto} for	% Lay down the rest of the path
} def

/PSL_labelclip
{		% This will create a total clip path for all the labels in PSL_txt
  /PSL_paintclippath exch 1 eq def			% true if we want to debug the path with painting
  /PSL_clippath true def
  /PSL_m1 PSL_m 1 sub def
  /PSL_justx PSL_just 4 mod 1 sub -0.5 mul def
  /PSL_justy PSL_just 4 idiv 2 sub PSL_height mul 2 div def
  /PSL_clipx PSL_m 5 mul array def
  /PSL_clipy PSL_m 5 mul array def
  /PSL_clipn 0 def
  /PSL_paintclippath PSL_paintclippath PSL_debug not and def	% painting means no debug
  0 1 PSL_m1				% Loop over all labels
  {
    /k exch def						% Current label index
    /xp PSL_txt_x k get def
    /yp PSL_txt_y k get def					% Get text placement point
    /MAT PSL_angle k get matrix rotate def			% Rotate the coordinate system to follow baseline text
    /W PSL_str k get stringwidth pop PSL_gap_x 2 mul add def	% Width of current label space including clearance
    /H PSL_height PSL_gap_y 2 mul add def				% Height of current label space including clearance
    /x0 0 W PSL_justx mul add def				% (x0,y0) is the rotated and adjusted text LL point relative to xp,yp
    /y0 0 PSL_justy add PSL_gap_y sub def
    /DX 0 0 W W 0 5 array astore def				% Offsets in x from LL
    /DY 0 H H 0 0 5 array astore def				% Offsets in y from LL
    0 1 4
    { % Visit all 5 points and append to clippath
      /ii exch def
      x0 DX ii get add y0 DY ii get add MAT transform
      /y1 exch def /x1 exch def
      PSL_clipx PSL_clipn xp x1 add put			% Add this x to clippath
      PSL_clipy PSL_clipn yp y1 add put			% Add this y to clippath		
      /PSL_clipn PSL_clipn 1 add def			% Goto next point
    } for
  } for
  newpath				% Start fresh
  PSL_debug not { gsave clippath } if
  PSL_placeclippath			% Lay down & clip with label paths
  PSL_debug
  {
    gsave 0.9 0.5 0.5 setrgbcolor fill grestore stroke
  }
  {
    clip				% Set the new clip path
  } ifelse
  PSL_paintclippath			% Debug option to see the clip path
  {
    gsave
    clippath 0.5 setgray fill
    grestore
  } if
  newpath			% Clean up and return
} def

/PSL_debug false def
