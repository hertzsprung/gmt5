<?xml version="1.0" encoding="UTF-8"?>
<!-- lifted from troff+man by doclifter -->
<refentry xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en' xml:id='pslib3'>




















































<refmeta>
<refentrytitle>PSL</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo class='source'>Mar 22 2012</refmiscinfo>
<refmiscinfo class='manual'>GMT 5.0.1b (SVN)</refmiscinfo>
</refmeta>
<refnamediv>
<refname>PSL 5.0</refname>
<refpurpose>A PostScript based plotting library</refpurpose>
</refnamediv>
<!-- body begins here -->

<refsect1 xml:id='description'><title>DESCRIPTION</title>
<para><emphasis remap='B'>PSL</emphasis> was created to make the generation of <emphasis remap='I'>PostScript</emphasis> page description code easier.
PS is a page description language developed by the Adobe for specifying how a
printer should render a page of text or graphics.
It uses a reverse Polish notation that puts and gets items from a stack to draws
lines, text, and images and even performs calculations.
<emphasis remap='B'>PSL</emphasis> is a self-contained library that presents a series of functions that can
be used to create plots.  The resulting <emphasis remap='I'>PostScript</emphasis> code is ASCII text (with some
exceptions for images if so desired) and can thus be edited using any text editor.  Thus,
it is possible to modify a plot file even after it has been created, e.g.,
to change text strings, set new gray shades or colors, experiment with various
pen widths, etc.  Furthermore, various tools exist that can parse <emphasis remap='I'>PostScript</emphasis> and let you make such edits via
a graphical user interface (e.g., Adobe Illustrator).
<emphasis remap='B'>PSL</emphasis> is written in C but includes FORTRAN bindings
and can therefore be called from both C and FORTRAN programs.
To use this library, you must link your plotting program with
<emphasis remap='B'>PSL</emphasis>.  <emphasis remap='B'>PSL</emphasis> is used by the <emphasis remap='B'>GMT</emphasis> graphics programs to generate PS.
<emphasis remap='B'>PSL</emphasis> output is freeform <emphasis remap='I'>PostScript</emphasis> that conforms to the Adobe <emphasis remap='I'>PostScript</emphasis>
File Specification Version 3.0.</para>

<para>Before any <emphasis remap='B'>PSL</emphasis> calls can be issued, the plotting system must be
initialized.  This is done by calling <emphasis remap='B'>PSL_beginsession</emphasis>, which initializes a new
<emphasis remap='B'>PSL</emphasis> session; then call <emphasis remap='B'>PSL_setdefaults</emphasis> which sets internal
variables and default settings, accepts settings for measurement units and character
encoding, and returns a pointer to a struct PSL_CTRL which must be passed as first
argument to all other <emphasis remap='B'>PSL</emphasis> functions.  The measure unit for sizes and positions can be set to be centimeter (c),
inch (i), meter (m), or points (p).  A <emphasis remap='B'>PSL</emphasis> session is terminated by calling <emphasis remap='B'>PSL_endsession</emphasis>.
You may create one or more plots within the same session.  A new plot is started
by calling <emphasis remap='B'>PSL_beginplot</emphasis>, which defines macros, sets up
the plot-coordinate system, scales, and [optionally] opens a file where all the
PS code will be written.  Normally, the plot code is written
to <emphasis remap='I'>stdout</emphasis>.  When all plotting to this file is done, you finalize the plot
by calling <emphasis remap='B'>PSL_endplot</emphasis>.</para>

<para>A wide variety of output devices that support <emphasis remap='I'>PostScript</emphasis> exist, including many printers
and large-format plotters.  Many tools exists to display <emphasis remap='I'>PostScript</emphasis> on a computer screen.
Open source tools such as ghostscript can be used to convert <emphasis remap='I'>PostScript</emphasis> into PDF or raster
images (e.g., TIFF, JPEG) at a user-defined resolution (DPI).  In particular, the
GMT tool ps2raster is a front-end to ghostscript and pre-selects the optimal options
for ghostscript that will render quality PDF and images.</para>

<para>The <emphasis remap='B'>PSL</emphasis> is fully 64-bit compliant.  Integer parameters are here specified by the type
<emphasis remap='B'>long</emphasis> to distinguish them from the 32-bit <emphasis remap='B'>int</emphasis>.  Note that under standard 32-bit
compilation they are equivalent.  Users of this library under 64-bit mode must make sure
they pass proper <emphasis remap='B'>long</emphasis> variables (under Unix flavors) or <emphasis remap='B'>__int64</emphasis> under Windows 64.</para>
</refsect1>

<refsect1 xml:id='units'><title>UNITS</title>
<para><emphasis remap='B'>PSL</emphasis> can be instructed to use centimeters, inches, meters or points as input units for the coordinates
and sizes of elements to be plotted. Any dimension that takes this setting as a unit is specified as
<emphasis remap='I'>user units</emphasis> or <emphasis remap='I'>plot units</emphasis> in this manual. Excluded from this are line widths and font sizes
which are always measured in <emphasis remap='I'>points</emphasis>.
The user units can be further refined by calling <emphasis remap='B'>PSL_beginaxes</emphasis>, giving
the user the opportunity to specify any linear coordinate frame. Changing the coordinate frame only
affects the coordinates of plotted material indicated as measured in <emphasis remap='I'>plot units</emphasis>, not the sizes of
symbols (which remain in <emphasis remap='I'>user units</emphasis>), nor line widths or font sizes (which remain in <emphasis remap='I'>points</emphasis>).</para>
</refsect1>

<refsect1 xml:id='color'><title>COLOR</title>
<para><emphasis remap='B'>PSL</emphasis> uses the direct color model where red, green, and blue are given separately,
each must be in the range from 0-1.  If red = -1 then no fill operation takes place.
If red = -3, then pattern fill will be used, and the green value will indicate the pattern to be
used.
Most plot-items can be plotted
with or without outlines.  If outline is desired (i.e., set to 1), it
will be drawn using the current line width and pattern. <emphasis remap='B'>PSL</emphasis> uses highly
optimized macro substitutions and scales the coordinates depending on the resolution
of the hardcopy device so that the output file is kept as compact as possible.</para>
</refsect1>

<refsect1 xml:id='justification'><title>JUSTIFICATION</title>
<para>Text strings, text boxes and images can be "justified" by specifying the corner to which the <emphasis remap='I'>x</emphasis> and <emphasis remap='I'>y</emphasis> coordinates of the subroutine call
apply. Nine different values are possible, as shown schematically in this diagram:</para>

  <blockquote remap='RS'>
<para>9------------10----------- 11</para>

<para>|                           |</para>

<para>5             6             7</para>

<para>|                           |</para>

<para>1------------ 2------------ 3
  </para></blockquote> <!-- remap='RE' -->
<para>The box represents the text or image.  E.g., to plot a text string with its center
at (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>), you must use <emphasis remap='I'>justify</emphasis> == 6. <emphasis remap='I'>justify</emphasis> == 0 means "no justification", which generally means (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) is
at the bottom left. Convenience values PSL_NONE, PSL_BL, PSL_BC, PSL_BL, PSL_ML, PSL_MC, PSL_MR, PSL_TL, PSL_TC and PSL_TR are
available.</para>
</refsect1>

<refsect1 xml:id='initialization'><title>INITIALIZATION</title>
<para>These functions initialize or terminate the <emphasis remap='B'>PSL</emphasis> system.  We use the term <emphasis remap='B'>PSL</emphasis> session to
indicate one instance of the <emphasis remap='B'>PSL</emphasis> system (a complicated program could run many <emphasis remap='B'>PSL</emphasis>
sessions concurrently as each would operate via its own control structure).  During a single
session, one or more plots may be created.  Here are the functions involved in initialization:</para>


<para><emphasis remap='B'>struct PS_CTRL *PSL_beginsession</emphasis> (<emphasis remap='B'>FILE</emphasis> <emphasis remap='I'>*err</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>unit</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>verbose</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>comments</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>compression</emphasis>,
<emphasis remap='B'>long</emphasis> <emphasis remap='I'>imgtype</emphasis>, <emphasis remap='B'>const char</emphasis> <emphasis remap='I'>*encoding</emphasis>)</para>
  <blockquote remap='RS'>
<para>This is the first function that must be called as it initializes a new <emphasis remap='B'>PSL</emphasis> session.  Specifically, it will
allocate a new <emphasis remap='B'>PSL</emphasis> control structure and initialize the session parameters to those given by the arguments.
Here, <emphasis remap='I'>err</emphasis> is a stream pointer indicating where error messages should go (if NULL we will use <emphasis remap='I'>stderr</emphasis>),
<emphasis remap='I'>unit</emphasis> indicates the units of the coordinates used in this session and must be one of PSL_CM (0), PSL_INCH (1), PSL_METER (2), or PSL_PT (3).
This setting tells the <emphasis remap='B'>PSL</emphasis> session what units are used for coordinates, distances and dimensions.
The <emphasis remap='I'>verbose</emphasis> setting indicates the <emphasis remap='I'>PostScript</emphasis> verbosity level (PSL_MSG_SILENCE = silence (0), PSL_MSG_FATAL = fatal errors (1),
PSL_MSG_NORMAL = warnings and progress (2), PSL_MSG_VERBOSE = extensive progress reports (3), or PSL_MSG_DEBUG = debugging (4)).
Set <emphasis remap='I'>comments</emphasis> to indicate if you want <emphasis remap='I'>PostScript</emphasis> comments to be written (PSL_YES = 1) or not (PSL_NO = 0).
The <emphasis remap='I'>compression</emphasis> parameter controls image compression (all are lossless).  Choose from PSL_NONE = none (0),
PSL_RLE = Run-length encoding (1), or PSL_LZW = Lempel-Ziv-Welch compression (2).
Use <emphasis remap='I'>imgtype</emphasis> to indicate whether images should be written in ASCII (PSL_ASCII = 0) or BINARY (PSL_BINARY = 2) format.
Note: if you use PSL_BINARY you may not be able to manually edit the <emphasis remap='I'>PostScript</emphasis> file or use it with GMT's ps2raster.
Finally, use <emphasis remap='I'>encoding</emphasis> to select the character encoding used.  Choose from Standard [Default if NULL is given],
Standard+, ISOLatin1, ISOLatin1+, ISO-8859-X (with X = 1-10, 13-15).  See GMT Appendix F for the enhanced Standard+
and ISOLatin1+ encodings.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_endsession</emphasis> (<emphasis remap='B'>struct PS_CTRL</emphasis> <emphasis remap='I'>*PSL</emphasis>)</para>
  <blockquote remap='RS'>
<para>This function terminates the active <emphasis remap='B'>PSL</emphasis> session; it is the last function you must call in your program.
Specifically, this function will deallocate memory used and free up resources.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_fopen</emphasis> (<emphasis remap='B'>char</emphasis> <emphasis remap='I'>*file</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>This function simply opens a file, just like fopen.  The reason it is replicated here is that under Windows,
file pointers must be assigned wihtin the same DLL as they are being used.  Yes, this is retarded but if we
do not do so then PSL will not work well under Windows.  Under non-Windows this functions is just a macro
that becomes fopen.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>void PSL_free</emphasis> (<emphasis remap='B'>void</emphasis> <emphasis remap='I'> *ptr</emphasis>)</para>
  <blockquote remap='RS'>
<para>This function frees up the memory allocated inside <emphasis remap='B'>PSL</emphasis>.  Programmers using C/C++ should now this is a macro
and there is no need to cast the pointer to <emphasis remap='I'>void *</emphasis> as this will be done by the macro.  Fortran programmers
should instead call <emphasis remap='B'>PSL_freefunction</emphasis>.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>void PSL_beginaxes</emphasis> (<emphasis remap='B'>struct PS_CTRL</emphasis> <emphasis remap='I'>*PSL</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> llx</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> lly</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> width</emphasis>,
<emphasis remap='B'>double</emphasis> <emphasis remap='I'> height</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> x0</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> y0</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> x1</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'> y1</emphasis>)</para>
  <blockquote remap='RS'>
<para>This function sets up the mapping that takes the users data coordinates and converts them to the positions
on the plot in <emphasis remap='I'>PostScript</emphasis> units.  This should be used when plotting data coordinates and is terminated with <emphasis remap='B'>PSL_endaxes</emphasis>,
which returns <emphasis remap='B'>PSL</emphasis> to the default measurement units and scaling. Here, <emphasis remap='I'>llx</emphasis> and <emphasis remap='I'>lly</emphasis> sets the lower left
position of the mapping region, while <emphasis remap='I'>width</emphasis> and <emphasis remap='I'>height</emphasis> sets the dimension of the plot area in user units.  Finally,
<emphasis remap='I'>x0</emphasis>, <emphasis remap='I'>x1</emphasis> and <emphasis remap='I'>y0</emphasis>, <emphasis remap='I'>y1</emphasis> indicate the range of the users x- and y-coordinates, respectively.
Specify a reverse axis direction (e.g., to let the y-axis be positive down) by setting <emphasis remap='I'>y0</emphasis> larger
than <emphasis remap='I'>y1</emphasis>, and similarly for an x-axis that increases to the left.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>void PSL_endaxes</emphasis> (<emphasis remap='B'>struct PS_CTRL</emphasis> <emphasis remap='I'>*PSL</emphasis>)</para>
  <blockquote remap='RS'>
<para>Terminates the map scalings initialized by <emphasis remap='B'>PSL_beginaxes</emphasis> and returns <emphasis remap='B'>PSL</emphasis> to standard scaling in measurement
units.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_beginplot</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>FILE</emphasis> <emphasis remap='I'>*fp</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>orientation</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>overlay</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>color_mode</emphasis>,
<emphasis remap='B'>char</emphasis> <emphasis remap='I'>origin</emphasis>[], <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>[], <emphasis remap='B'>double</emphasis> <emphasis remap='I'>page_size</emphasis>[], <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*title</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>font_no</emphasis>[])</para>
  <blockquote remap='RS'>
<para>Controls the initiation (or continuation) of a particular plot within the current session.
Pass file pointer <emphasis remap='I'>fp</emphasis> where the <emphasis remap='I'>PostScript</emphasis> code will be written; if NULL then the output is written to <emphasis remap='I'>stdout</emphasis>.
The Fortran interface always sends to <emphasis remap='I'>stdout</emphasis>.
The <emphasis remap='I'>orientation</emphasis> may be landscape (PSL_LANDSCAPE or 0) or portrait (PSL_PORTRAIT or 1).
Set <emphasis remap='I'>overlay</emphasis> to PSL_OVERLAY (0) if the following <emphasis remap='I'>PostScript</emphasis> code should be appended to an existing plot;
otherwise pass PSL_INIT (1) to start a new plot. Let <emphasis remap='I'>colormode</emphasis> be one of PSL_RGB (0), PSL_CMYK (1), PSL_HSV (2) or PSL_GRAY (3);
this setting controls how colors are presented in the <emphasis remap='I'>PostScript</emphasis> code.
The <emphasis remap='I'>origin</emphasis> setting determines for x and y separately the origin of the specified offsets (next
argument). Each of the two characters are either
&acute;r' for an offset relative to the current origin,
&acute;a' for a temporaty adjustment of the origin which is undone during <emphasis remap='B'>PSL_endplot</emphasis>,
&acute;f' for a placement of the origin relative to the lower left corner of the page,
&acute;c' for a placement of the origin relative to the center of the page.
The array <emphasis remap='I'>offset</emphasis> specifies the offset of the new origin relative to the position indicated by <emphasis remap='B'>origin</emphasis>.
<emphasis remap='I'>page_size</emphasis> means the physical width and height of the plotting media in points (typically 612 by 792 for
Letter or 595 by 842 for A4 format). 
The character string <emphasis remap='I'>title</emphasis> can be used to specify the <emphasis remap='B'>%%Title:</emphasis> header in the <emphasis remap='I'>PostScript</emphasis> file (or use NULL for the default).
The array <emphasis remap='I'>font_no</emphasis> specifies all fonts used in the plot (by number), or use NULL to leave out the
<emphasis remap='B'>%%DocumentNeededResources:</emphasis> comment in the <emphasis remap='I'>PostScript</emphasis> file.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_endplot</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>last_page</emphasis>)</para>
  <blockquote remap='RS'>
<para>Terminates the plotting sequence and closes plot file (if other than <emphasis remap='I'>stdout</emphasis>). If
<emphasis remap='I'>last_page</emphasis> == PSL_FINALIZE (1), then a <emphasis remap='I'>PostScript</emphasis> <emphasis remap='I'>showpage</emphasis> command is issued, which initiates
the printing process on hardcopy devices.  Otherwise, pass PSL_OVERLAY (0).
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setorigin</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>xorigin</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>yorigin</emphasis>,
<emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the coordinate system by translating by (<emphasis remap='I'>xorigin</emphasis>,<emphasis remap='I'>yorigin</emphasis>) followed by a <emphasis remap='I'>angle</emphasis>-degree rotation (<emphasis remap='I'>mode</emphasis>=PSL_FWD or 0)
or alternatively the rotation followed by translation (<emphasis remap='I'>mode</emphasis>=PSL_INV or 1).
  </para></blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='changing_settings'><title>CHANGING SETTINGS</title>
<para>The following functions are used to change various <emphasis remap='B'>PSL</emphasis> settings and affect the current state of parameters such as line and
fill attributes.</para>


<para><emphasis remap='B'>long PSL_define_pen</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*name</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>width</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*style</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>rgb</emphasis>[])</para>
  <blockquote remap='RS'>
<para>Stores the specified pen characteristics in a <emphasis remap='I'>PostScript</emphasis> variable called <emphasis remap='I'>name</emphasis>.  This can be used to place
certain pen attributes in the <emphasis remap='I'>PostScript</emphasis> file and then retrieve them later with <emphasis remap='B'>PSL_load_pen</emphasis>.  This makes
the stored pen the current pen.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_define_rgb</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*name</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>rgb</emphasis>[])</para>
  <blockquote remap='RS'>
<para>Stores the specified color in a <emphasis remap='I'>PostScript</emphasis> variable called <emphasis remap='I'>name</emphasis>.  This can be used to place
certain color values in the <emphasis remap='I'>PostScript</emphasis> file and then retrieve them later with <emphasis remap='B'>PSL_load_rgb</emphasis>.
This makes the stored color the current color.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setcolor</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>rgb</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Sets the current color for all stroked (mode = PSL_IS_STROKE (0)) or filled (mode = PSL_IS_FILL (1))
material to follow (lines, symbol outlines, text).
<emphasis remap='I'>rgb</emphasis> is a triplet of red, green and blue values in the range 0.0 through 1.0.
Set the red color to -3.0 and the green color to the pattern number returned by <emphasis remap='B'>PSL_setpattern</emphasis>
to select a pattern as current paint color.  For PDF transparency, set <emphasis remap='I'>rgb</emphasis>[3] to a value
between 0 (opaque) and 1 (fully transparent).
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setpattern</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>image_no</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*imagefile</emphasis>,
<emphasis remap='B'>long</emphasis> <emphasis remap='I'>dpi</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>f_rgb</emphasis>[], <emphasis remap='B'>double</emphasis> <emphasis remap='I'>b_rgb</emphasis>[])</para>
  <blockquote remap='RS'>
<para>Sets up the specified image pattern as the fill to use for polygons and symbols.
Here, <emphasis remap='I'>image_no</emphasis> is the number of the standard PSL fill patterns (1-90; use a negative number when you specify
an image <emphasis remap='I'>filename</emphasis> instead.  The scaling (i.e., resolution in dots per inch) of the pattern is controlled by the image <emphasis remap='I'>dpi</emphasis>; if
set to 0 it will be plotted at the device resolution.
The two remaining settings apply to 1-bit images only and are otherwise ignored:
You may replace the foreground color (the set bits) with the
<emphasis remap='I'>f_rgb</emphasis> color and the background color (the unset bits) with <emphasis remap='I'>b_rgb</emphasis>.  Alternatively, pass either color with
the red component set to -1.0 and we will instead issue an image mask that is see-through for the specified
fore- or background component.
To subsequently use the pattern as a pen or fill color,
use <emphasis remap='B'>PSL_setcolor</emphasis> or DB(PSL_setfill) with the a color <emphasis remap='I'>rgb</emphasis> code made up of <emphasis remap='I'>r</emphasis> = -3, and <emphasis remap='I'>b</emphasis> = the pattern
number returned by <emphasis remap='B'>PSL_setpattern</emphasis>.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setdash</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*pattern</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current pen style attributes.  The character string <emphasis remap='I'>pattern</emphasis> contains the desired
pattern using a series of lengths in points specifying the alternating lengths of dashes and gaps in points.
E.g., "4 2" and <emphasis remap='I'>offset</emphasis> = 1 will plot like</para>
  <blockquote remap='RS'>
<para>x ----  ----  ---- 
    </para></blockquote> <!-- remap='RE' -->
<para>where x is starting point of a line (The x is not plotted).  That is, the line is made up of a repeating pattern of a
4 points long solid line and a 2 points long gap, starting 1 point after the x.  To reset to solid line,
specify <emphasis remap='I'>pattern</emphasis> = NULL ("") and <emphasis remap='I'>offset</emphasis> = 0.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setfill</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>rgb</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>outline</emphasis>)</para>
  <blockquote remap='RS'>
<para>Sets the current fill color and whether or not outline is needed for symbols.  Special cases
are handled by passing the red color as -1.0 (no fill), -2.0 (do not change the outline setting)
or -3.0 (select the image pattern indicated by the second (green) element of <emphasis remap='I'>rgb</emphasis>).
For PDF transparency, set <emphasis remap='I'>rgb</emphasis>[3] to a value between 0 (opaque) and 1 (fully transparent).
Set outline to PSL_OUTLINE (1) to draw the outlines of polygons and symbols using the current pen.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setfont</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>fontnr</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current font number to <emphasis remap='I'>fontnr</emphasis>.  The fonts available are:  0 = Helvetica,
1 = H. Bold, 2 = H. Oblique, 3 = H. Bold-Oblique, 4 = Times, 5 =
T. Bold, 6 = T. Italic, 7 = T. Bold Italic, 8 = Courier, 9 = C. Bold,
10 = C Oblique, 11 = C Bold Oblique, 12 = Symbol, 13 = AvantGarde-Book,
14 = A.-BookOblique, 15 = A.-Demi, 16 = A.-DemiOblique, 17 = Bookman-Demi,
18 = B.-DemiItalic, 19 = B.-Light, 20 = B.-LightItalic, 21 = Helvetica-Narrow,
22 = H-N-Bold, 23 = H-N-Oblique, 24 = H-N-BoldOblique, 25 = NewCenturySchlbk-Roman, 
26 = N.-Italic, 27 = N.-Bold, 28 = N.-BoldItalic,
29 = Palatino-Roman, 30 = P.-Italic, 31 = P.-Bold, 32 = P.-BoldItalic,
33 = ZapfChancery-MediumItalic, 34 = ZapfDingbats, 35 = Ryumin-Light-EUC-H,
36 = Ryumin-Light-EUC-V, 37 = GothicBBB-Medium-EUC-H, and 38 = GothicBBB-Medium-EUC-V.
If <emphasis remap='I'>fontnr</emphasis> is outside this range, it is reset to 0.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setformat</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>n_decimals</emphasis>)</para>
  <blockquote remap='RS'>
<para>Sets the number of decimals to be used when writing color or gray values.  The default
setting of 3 gives 1000 choices per red, green, and blue value, which is more than
the 255 choices offered by most 24-bit platforms.  Choosing a lower value will make
the output file smaller at the expense of less color resolution.  Still, a value of 2
gives 100 x 100 x 100 = 1 million colors, more than most eyes can distinguish.  For
a setting of 1, you will have 10 nuances per primary color and a total of 1000 unique
combinations.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setlinewidth</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>linewidth</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current line width in points.  Specifying 0 gives the thinnest
line possible, but this is implementation-dependent (seems to work fine on most <emphasis remap='I'>PostScript</emphasis> printers).
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setlinecap</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>cap</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current line cap, i.e., what happens at the beginning and end of a line segment.
PSL_BUTT_CAP (0) gives butt line caps [Default], PSL_ROUND_CAP (1)
selects round caps, while PSL_SQUARE_CAP (2) results in square caps.  THus, the two last options
will visually lengthen a straight line-segment by half the line width at either end.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setlinejoin</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>join</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current linejoin setting, which handles how lines of finite thickness are joined
together when the meet at different angles.  PSL_MITER_JOIN (0) gives a mitered joint [Default],
PSL_ROUND_JOIN (1) makes them round, while PSL_BEVEL_JOIN (2) produces bevel joins.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setmiterlimit</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>limit</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current miter limit used for mitered joins.  PSL_MITER_DEFAULT (35) gives the default 
PS miter; other values are interpreted as the cutoff acute angle (in degrees) when mitering becomes
active.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_settransparencymode</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Changes the current PDF transparency rendering mode [Default is Normal].  Choose among
Color, ColorBurn, ColorDodge, Darken, Difference, Exclusion, HardLight, Hue,
Lighten, Luminosity, Multiply, Normal, Overlay, Saturation, SoftLight, and Screen.
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_setdefaults</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>xyscales</emphasis>[], <emphasis remap='B'>double</emphasis> <emphasis remap='I'>pagergb</emphasis>[], <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*encoding</emphasis>)</para>
  <blockquote remap='RS'>
<para>Allows changes to the PSL session settings and should be called immediately after <emphasis remap='B'>PSL_beginsession</emphasis>.
The <emphasis remap='I'>xyscales</emphasis> array affect an overall magnification of your plot [1,1].  This can be useful if you
design a page-sized plot but would then like to magnify (or shrink) it by a given factor.
Change the default paper media color [white; 1/1/1] by
specifying an alternate page color.  Passing zero (or NULL for <emphasis remap='I'>pagergb</emphasis>) will leave the setting unchanged.
Finally, pass the name of the character set encoding (if NULL we select Standard).
  </para></blockquote> <!-- remap='RE' -->


<para><emphasis remap='B'>long PSL_defunits</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*name</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>value</emphasis>)</para>
<literallayout remap='RS'>
Creates a <emphasis remap='I'>PostScript</emphasis> variable called <emphasis remap='I'>name</emphasis> and initializes it to the equivalent of <emphasis remap='I'>value</emphasis> user units.
</literallayout> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_defpoints</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*name</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>)</para>
  <blockquote remap='RS'>
<para>Creates a <emphasis remap='I'>PostScript</emphasis> variable called <emphasis remap='I'>name</emphasis> and initializes it to the value that corresponds to the font size (in points) given by
<emphasis remap='I'>fontsize</emphasis>.
  </para></blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='plotting_lines_and_polygons'><title>PLOTTING LINES AND POLYGONS</title>
<para>Here are functions used to plot lines and closed polygons, which may optionally be filled.  The attributes
used for drawing and filling are set prior to calling these functions; see CHANGING SETTINGS above.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_plotarc</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>radius</emphasis>,
<emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle1</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle2</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>type</emphasis>)</para>
  <blockquote remap='RS'>
<para>Draws a circular arc with its center at plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>), starting from angle <emphasis remap='I'>angle1</emphasis> and end at <emphasis remap='I'>angle2</emphasis>.
Angles must be given in decimal degrees.  If <emphasis remap='I'>angle1</emphasis> &gt; <emphasis remap='I'>angle2</emphasis>, a negative arc is
drawn. The <emphasis remap='I'>radius</emphasis> is in user units. The <emphasis remap='I'>type</emphasis> determines how the arc is interpreted: PSL_MOVE (1) means set new anchor
point, PSL_STROKE (2) means stroke the arc, PSL_MOVE + PSL_STROKE (3) means both, whereas PSL_DRAW (0)
justs adds to arc path to the current path.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotline</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>n</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>type</emphasis>)</para>
  <blockquote remap='RS'>
<para>Assemble a continuous line through <emphasis remap='I'>n</emphasis> points whose the plot coordinates are in the <emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis> arrays.
To continue an existing line, use <emphasis remap='I'>type</emphasis> = PSL_DRAW (0), or if this is
the first segment in a multisegment path, set <emphasis remap='I'>type</emphasis> = PSL_MOVE (1).  To end
the segments and draw the lines, add PSL_STROKE (2).  Thus, for a single
segment, <emphasis remap='I'>type</emphasis> must be PSL_MOVE + PSL_STROKE (3).  The line is drawn using the current pen attributes.
Add PSL_CLOSE (8) to <emphasis remap='I'>type</emphasis> to close the first and last point by the <emphasis remap='I'>PostScript</emphasis> operators.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotpoint</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>type</emphasis>)</para>
  <blockquote remap='RS'>
<para>Moves the pen from the current to the specified plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) and optionally
draws and strokes the line, depending on <emphasis remap='I'>type</emphasis>.
Specify <emphasis remap='I'>type</emphasis> as either a move (PSL_MOVE, 1), or draw (PSL_DRAW, 2),
or draw and stroke (PSL_DRAW + PSL_STOKE, 3) using current pen attributes.
It the coordinates are relative to the current point add PSL_REL (4) to <emphasis remap='I'>type</emphasis>.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotbox</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x0</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y0</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x1</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y1</emphasis>)</para>
  <blockquote remap='RS'>
<para>Creates a closed box with opposite corners at plot coordinates (<emphasis remap='I'>x0</emphasis>,<emphasis remap='I'>y1</emphasis>) and (<emphasis remap='I'>x1</emphasis>,<emphasis remap='I'>y1</emphasis>).  The box may be filled and its outline
stroked depending on the current settings for fill and pen attributes.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotpolygon</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>n</emphasis>)</para>
  <blockquote remap='RS'>
<para>Creates a closed polygon through <emphasis remap='I'>n</emphasis> points whose plot coordinates are in the <emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis> arrays.
The polygon may be filled and its outline stroked depending on the current settings for fill and pen attributes.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotsegment</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x0</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y0</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x1</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y1</emphasis>)</para>
  <blockquote remap='RS'>
<para>Draws a line segment between the two points (plot coordinates) using the current pen
attributes.
  </para></blockquote> <!-- remap='RE'
.br -->

</refsect1>

<refsect1 xml:id='plotting_symbols'><title>PLOTTING SYMBOLS</title>
<para>Here are functions used to plot various geometric symbols or constructs.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_plotaxis</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>tickval</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*label</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>side</emphasis>)</para>
  <blockquote remap='RS'>
<para>Plots a basic axis with tick marks, annotations, and label.  Assumes that <emphasis remap='B'>PSL_beginaxes</emphasis> has been called to
set up positioning and user data ranges.  Annotations will be set using the <emphasis remap='I'>fontsize</emphasis> in points.
<emphasis remap='I'>side</emphasis> can be 0, 1, 2, or 3, which selects lower x-axis, right y-axis, upper x-axis, or left y-axis, respectively.
The <emphasis remap='I'>label</emphasis> font size is set to 1.5 times the <emphasis remap='I'>fontsize</emphasis>.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotsymbol</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>size</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>symbol</emphasis>)</para>
  <blockquote remap='RS'>
<para>Plots a simple geometric symbol centered on plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>).  The argument <emphasis remap='I'>symbol</emphasis> selects the geometric symbol to use.
Most symbols are scaled to fit inside a circle of diameter given as <emphasis remap='I'>size</emphasis>[0], but some symbols take additional parameters.
Choose from these 1-parameter symbols using the predefined self-explanatory integer values
PSL_CIRCLE, PSL_DIAMOND, PSL_HEXAGON, PSL_INVTRIANGLE, PSL_OCTAGON, PSL_PENTAGON, PSL_SQUARE, PSL_STAR, and PSL_TRIANGLE; these
may all be filled and stroked if <emphasis remap='B'>PSL_setfill</emphasis> has been called first.  In addition, you can choose several line-only symbols that cannot be filled.
They are PSL_CROSS, PSL_DOT, PSL_PLUS, PSL_XDASH, and PSL_YDASH.
Finally, more complicated symbols require more than one parameter to be passed via <emphasis remap='I'>size</emphasis>. These are
PSL_ELLIPSE (<emphasis remap='I'>size</emphasis> is expected to contain the three parameter <emphasis remap='I'>angle</emphasis>, <emphasis remap='I'>major</emphasis>, and <emphasis remap='I'>minor</emphasis> axes,
which defines an ellipse with its major axis rotated by <emphasis remap='I'>angle</emphasis> degrees),
PSL_MANGLE (<emphasis remap='I'>size</emphasis> is expected to contain the 8 parameters <emphasis remap='I'>radius</emphasis>, <emphasis remap='I'>angle1</emphasis>, and <emphasis remap='I'>angle2</emphasis> for the math angle specification,
followed by <emphasis remap='I'>tailwidth</emphasis>, <emphasis remap='I'>headlength</emphasis>, <emphasis remap='I'>headwidth</emphasis>, <emphasis remap='I'>shape</emphasis>, and <emphasis remap='I'>status</emphasis> (see PSL_VECTOR below for explanation),
PSL_WEDGE (<emphasis remap='I'>size</emphasis> is expected to contain the three parameter <emphasis remap='I'>radius</emphasis>, <emphasis remap='I'>angle1</emphasis>, and <emphasis remap='I'>angle2</emphasis> for the sector specification),
PSL_RECT (<emphasis remap='I'>size</emphasis> is expected to contain the two dimensions <emphasis remap='I'>width</emphasis> and <emphasis remap='I'>height</emphasis>),
PSL_RNDRECT (<emphasis remap='I'>size</emphasis> is expected to contain the two dimensions <emphasis remap='I'>width</emphasis> and <emphasis remap='I'>height</emphasis> and the <emphasis remap='I'>radius</emphasis> of the corners),
PSL_ROTRECT (<emphasis remap='I'>size</emphasis> is expected to contain the three parameter <emphasis remap='I'>angle</emphasis>, <emphasis remap='I'>width</emphasis>, and <emphasis remap='I'>height</emphasis>, with rotation relative to the horizontal), and
PSL_VECTOR (<emphasis remap='I'>size</emphasis> is expected to contain the 7 parameters <emphasis remap='I'>x_tip</emphasis>, <emphasis remap='I'>y_tip</emphasis>, <emphasis remap='I'>tailwidth</emphasis>, <emphasis remap='I'>headlength</emphasis>, <emphasis remap='I'>headwidth</emphasis>, <emphasis remap='I'>shape</emphasis>, and <emphasis remap='I'>status</emphasis>.
Here (<emphasis remap='I'>x_tip</emphasis>,<emphasis remap='I'>y_tip</emphasis>) are the coordinates to the head of the vector, while (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) are those of the tail.
<emphasis remap='I'>shape</emphasis> can take on values from 0-1 and specifies how far the intersection point between the base of a
straight vector head and the vector line is moved toward the tip.  0.0 gives a triangular
head, 1.0 gives an arrow shaped head. The <emphasis remap='I'>status</emphasis> value is a bit-flag being the sum of several possible contributions:
PSL_VEC_RIGHT (2) = only draw right half of vector head,
PSL_VEC_BEGIN (4) = place vector head at beginning of vector,
PSL_VEC_END (8) = place vector head at end of vector,
PSL_VEC_JUST_B (0) = align vector beginning at (x,y),
PSL_VEC_JUST_C (16) = align vector center at (x,y),
PSL_VEC_JUST_E (32) = align vector end at (x,y),
PSL_VEC_JUST_S (64) = align vector center at (x,y),
PSL_VEC_OUTLINE (128) = draw vector head outline using default pen,
PSL_VEC_FILL (512) = fill vector head using default fill,
PSL_VEC_MARC90 (2048) = if angles subtend 90, draw straight angle symbol (PSL_MANGLE only).
The symbol may be filled and its outline stroked depending on the current settings for fill and pen attributes.
  </para></blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='plotting_images'><title>PLOTTING IMAGES</title>
<para>Here are functions used to read and plot various images.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_plotbitimage</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>xsize</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>ysize</emphasis>,
<emphasis remap='B'>int</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>unsigned char</emphasis> <emphasis remap='I'>buffer</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>nx</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>ny</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>f_rgb</emphasis>[], <emphasis remap='B'>double</emphasis> <emphasis remap='I'>b_rgb</emphasis>[])</para>
  <blockquote remap='RS'>
<para>Plots a 1-bit image image at plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) justified as per the argument <emphasis remap='I'>justify</emphasis> (see <emphasis remap='B'>JUSTIFICATION</emphasis> for
details).
The target size of the image is given by <emphasis remap='I'>xsize</emphasis> and <emphasis remap='I'>ysize</emphasis> in user units. If one of these is specified as zero, the
corresponding size is adjusted to the other such that the aspect ratio of the original image is retained.
<emphasis remap='I'>buffer</emphasis> is an unsigned character array in scanline orientation with 8 pixels per byte.  <emphasis remap='I'>nx</emphasis>, <emphasis remap='I'>ny</emphasis>
refers to the number of pixels in the image.  The rowlength of <emphasis remap='I'>buffer</emphasis> must
be an integral number of 8; pad with zeros.  <emphasis remap='I'>buffer</emphasis>[0] is upper left corner.
You may replace the foreground color (the set bits) with the
<emphasis remap='I'>f_rgb</emphasis> color and the background color (the unset bits) with <emphasis remap='I'>b_rgb</emphasis>.  Alternatively, pass either color with
the red component set to -1.0 and we will instead issue an image mask that is see-through for the specified
fore- or background component.
See the Adobe Systems <emphasis remap='I'>PostScript</emphasis> Reference Manual for more details.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotcolorimage</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>xsize</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>ysize</emphasis>,
<emphasis remap='B'>int</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>unsigned char</emphasis> <emphasis remap='I'>*buffer</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>nx</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>ny</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>depth</emphasis>)</para>
  <blockquote remap='RS'>
<para>Plots a 1-, 2-, 4-, 8-, or 24-bit deep image at plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) justified as per the argument <emphasis remap='I'>justify</emphasis> (see
<emphasis remap='B'>JUSTIFICATION</emphasis> for details).
The target size of the image is given by <emphasis remap='I'>xsize</emphasis> and <emphasis remap='I'>ysize</emphasis> in user units. If one of these is specified as zero, the
corresponding size is adjusted to the other such that the aspect ratio of the original image is retained.
This functions sets up a call to the <emphasis remap='I'>PostScript</emphasis> colorimage or image operators.
The pixel values are stored in <emphasis remap='I'>buffer</emphasis>, an unsigned character array in scanline orientation with gray shade or r/g/b
values (0-255).  <emphasis remap='I'>buffer</emphasis>[0] is the upper left corner.
<emphasis remap='I'>depth</emphasis> is number of bits per pixel (24, 8, 4, 2, or 1).
<emphasis remap='I'>nx</emphasis>, <emphasis remap='I'>ny</emphasis> refers to the number of pixels in image.
The rowlength of <emphasis remap='I'>buffer</emphasis> must be an integral number of 8/<emphasis remap='I'>Idepth</emphasis>.
E.g. if <emphasis remap='I'>depth</emphasis> = 4, then <emphasis remap='I'>buffer</emphasis>[j]/16
gives shade for pixel[2j-1] and <emphasis remap='I'>buffer</emphasis>[j%16 (mod 16) gives shade for pixel[2j].
When <option>-depth</option> is passed instead then "hardware" interpolation of the image is requested (this is implementation dependent).
If <option>-nx</option> is passed with 8- (or 24-) bit images then the first one (or three) bytes of <emphasis remap='I'>buffer</emphasis>
holds the gray (or r/g/b) color for pixels that are to be masked out using the PS
Level 3 Color Mask method.
See the Adobe Systems <emphasis remap='I'>PostScript</emphasis> Reference Manual for more details.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotepsimage</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>xsize</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>ysize</emphasis>,
<emphasis remap='B'>int</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>unsigned char</emphasis> <emphasis remap='I'>*buffer</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>size</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>nx</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>ny</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>ox</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>oy</emphasis>)</para>
  <blockquote remap='RS'>
<para>Plots an Encapsulated <emphasis remap='I'>PostScript</emphasis> (EPS) image at plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) justified as per the argument <emphasis remap='I'>justify</emphasis> (see <emphasis remap='B'>JUSTIFICATION</emphasis>
for details).
The target size of the image is given by <emphasis remap='I'>xsize</emphasis> and <emphasis remap='I'>ysize</emphasis> in user units. If one of these is specified as zero, the
corresponding size is adjusted to the other such that the aspect ratio of the original image is retained.
The EPS file is stored in <emphasis remap='I'>buffer</emphasis> and has <emphasis remap='I'>size</emphasis> bytes.
This function simply includes the image in the <emphasis remap='I'>PostScript</emphasis> output stream within an appropriate wrapper.
Specify position of lower left corner and size of image.
<emphasis remap='I'>nx</emphasis>, <emphasis remap='I'>ny</emphasis>, <emphasis remap='I'>ox</emphasis>, <emphasis remap='I'>oy</emphasis> refers to the width, height and origin (lower left corner) of the BoundingBox in points.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_loadimage</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>FILE</emphasis> <emphasis remap='I'>*fp</emphasis>, <emphasis remap='B'>struct imageinfo</emphasis> <emphasis remap='I'>*header</emphasis>, <emphasis remap='B'>unsigned char</emphasis> <emphasis remap='I'>**image</emphasis>)</para>
  <blockquote remap='RS'>
<para>Reads the image contents of the EPS file or a raster image pointed to by the open file pointer <emphasis remap='I'>fp</emphasis>.
The routine can handle Encapsulated <emphasis remap='I'>PostScript</emphasis> files or 1-, 8-, 24-, or 32-bit raster images in old, standard,
run-length encoded, or RGB-style Sun format.  Non-Sun rasters are automatically reformatted to Sun rasters
via a system call to ImageMagick's BD(convert), if installed.  The image is returned via the IT(image) pointer.\"'
  </para></blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='plotting_text'><title>PLOTTING TEXT</title>
<para>Here are functions used to read and plot text strings and paragraphs.  This can be somewhat complicated since
we rely on the <emphasis remap='I'>PostScript</emphasis> interpreter to determine the exact dimensions of text items given the font chosen.  For
perfect alignment you may have to resort to calculate offsets explicitly using <emphasis remap='B'>long PSL_deftextdim</emphasis>, <emphasis remap='B'>PSL_set_height</emphasis> and others
and issue calculations with <emphasis remap='B'>PSL_setcommand</emphasis>.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_plottext</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>The <emphasis remap='I'>text</emphasis> is plotted starting at plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) and will make an <emphasis remap='I'>angle</emphasis> with the horizontal.  The
point (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) maps onto different points of the text-string by giving various values for <emphasis remap='I'>justify</emphasis> (see <emphasis remap='B'>JUSTIFICATION</emphasis>
for details).
If <emphasis remap='I'>justify</emphasis> is negative, then all leading and trailing
blanks are stripped before plotting.  Certain character sequences (flags) have special
meaning to <emphasis remap='B'>PSL_plottext</emphasis>. @~ toggles between current font and the Mathematical Symbols font.
@%<emphasis remap='I'>no</emphasis>% selects font <emphasis remap='I'>no</emphasis> while @%% resets to the previous font.
@- turns subscript on/off, @+ turns superscript on/off, @# turns small caps
on/off, and @&bsol; will make a composite character of the following two character.
@;<emphasis remap='I'>r/g/b</emphasis>; changes the font color while @;; resets it [optionally append =<emphasis remap='I'>transparency</emphasis> to
change the transparency (0--100) of the text (the Default is opaque or 0)], @:<emphasis remap='I'>size</emphasis>: changes the font size (@:: resets it),
and @_ toggles underline on/off. If <emphasis remap='I'>text</emphasis> is NULL then we assume <emphasis remap='B'>PSL_plottextbox</emphasis> was called first.
Give <emphasis remap='I'>fontsize</emphasis> in points.  Normally, the text is typed using solid characters
in the current color (set by <emphasis remap='B'>PSL_setcolor</emphasis>).
To draw outline characters, set <emphasis remap='I'>mode</emphasis> == 1; the outline will get the current color and the text is
filled with the current fill color (set by <emphasis remap='B'>PSL_setfill</emphasis>).  Use <emphasis remap='I'>mode</emphasis> == 2 if the current fill is
a pattern.
If <emphasis remap='I'>fontsize</emphasis> is negative it means that the current point has already been set before <emphasis remap='B'>PSL_plottext</emphasis> was called and that
(<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>) should be ignored.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plottextbox</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>,
<emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>This function is used in conjugation with <emphasis remap='B'>PSL_plottext</emphasis> when a box surrounding the
text string is desired.  Taking most of the arguments of <emphasis remap='B'>PSL_plottext</emphasis>, the user must
also specify <emphasis remap='I'>mode</emphasis> to indicate whether the box needs rounded (PSL_YES = 1) or straight (PSL_NO = 0) corners.
The box will be colored with the current fill style set by <emphasis remap='B'>PSL_setfill</emphasis>. That means, if an outline
is desired, and the color of the inside of the box should be set with that routine.
The outline will be drawn with the current pen color (and width).
The <emphasis remap='I'>offset</emphasis> array holds the horizontal and vertical distance gaps between text and the surrounding
text box in distance units. The smaller of the two determined the radius of the rounded corners (if requested).
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plottextclip</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>n</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>,
<emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>[], <emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>This function is called twice: First time we pass the text strings and other parameters and use <emphasis remap='I'>PostScript</emphasis> to compute
clip paths so that no feature plotted after this call will be visible in areas where text will be plotted.
The second call actually plots the texts in the predetermined locations (NULL may be passed for all arrays for
the second call).  All labels have a straight baseline (for plotting along curved text, see <emphasis remap='B'>PSL_plottextpath</emphasis>).
The <emphasis remap='I'>x</emphasis> and <emphasis remap='I'>y</emphasis> arrays contain the plot coordinates where labels will be plotted; there are
<emphasis remap='I'>n</emphasis> such labels and locations.  Each label has its own entry in the <emphasis remap='I'>angle</emphasis> array.  The <emphasis remap='I'>text</emphasis> is an
array of text pointers to the individual text items, which will all appear using the current font and scaled
to specified <emphasis remap='I'>fontsize</emphasis> in points.  The <emphasis remap='I'>offset</emphasis> array holds the horizontal and vertical distance gaps between text and the surrounding
text box in user units (the clip path is the combination of all these text boxes).  Use <emphasis remap='I'>justify</emphasis> to specify how the
text string relates to the coordinates (see <emphasis remap='B'>JUSTIFICATION</emphasis> for details).  Finally, <emphasis remap='I'>mode</emphasis> is a bit pattern that
controls how the function does its work; pass <emphasis remap='I'>mode</emphasis> as the sum of the values you need:  0 = lay down clip path,
1 = place the text, 2 = turn off clipping, 4 = draw the <emphasis remap='I'>x-y</emphasis> line (useful for debugging), 8 = reuse the previous
parameters (so pass NULL as args), 16 = construct rounded text boxes [Default is rectangular], 
128 = fill the text box (this requires you to first define the text box rgb color with <emphasis remap='B'>PSL_define_rgb</emphasis> by setting
a local <emphasis remap='I'>PostScript</emphasis> variable that must be called PSL_setboxrgb), and 256 = draw the text box outlines (this requires you to
first define the text box pen with <emphasis remap='B'>PSL_define_pen</emphasis> by setting a local <emphasis remap='I'>PostScript</emphasis> variable that must be called PSL_setboxpen).
For font color you must use <emphasis remap='B'>PSL_define_rgb</emphasis> and create a <emphasis remap='I'>PostScript</emphasis> variable called PSL_settxtrgb.  If not set we default
to black.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_deftextdim</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*prefix</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>)</para>
  <blockquote remap='RS'>
<para>Computes the dimensions (width and height) required by the selected <emphasis remap='I'>text</emphasis> given the current font and its <emphasis remap='I'>fontsize</emphasis> (in points).
The values are stored as <emphasis remap='I'>PostScript</emphasis> variables called <emphasis remap='I'>prefix</emphasis>_w and <emphasis remap='I'>prefix</emphasis>_h, respectively.  This function can be
used to compute dimensions and, via BF(PSL_setcommand), calculate chances to position a particular item should be
plotted.  For instance, if you compute a position this way and wish to plot the text there, pass the coordinates
to <emphasis remap='B'>PSL_plottext</emphasis> as NaNs.
If <emphasis remap='I'>prefix</emphasis> is BF(-w), BF(-h), BF(-d) or BF(-b), no <emphasis remap='I'>PostScript</emphasis> variables will be assigned, but the values of
width, height, depth, or both width and height will be left on the <emphasis remap='I'>PostScript</emphasis> stack.
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_setparagraph</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>line_space</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>par_width</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>par_just</emphasis>)</para>
  <blockquote remap='RS'>
<para>Initialize common settings to be used when typesetting paragraphs of text with <emphasis remap='B'>PSL_plotparagraph</emphasis>.
Specify the line spacing (1 equals the font size) and paragraph width (in distance units).
Text can be aligned left (PSL_BL), centered  (PSL_BC), right (PSL_BR), or
justified (PSL_JUST) and is controlled by <emphasis remap='I'>par_just</emphasis>.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_plotparagraphbox</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>,
<emphasis remap='B'>long</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Computes and plots the text rectangle for a paragraph using the specified <emphasis remap='I'>fontsize</emphasis> (in points).
Here, <emphasis remap='I'>text</emphasis> is an array of the text to be typeset, using the settings
initialized by <emphasis remap='B'>PSL_setparagraph</emphasis>.  The escape sequences described for <emphasis remap='B'>PSL_plottext</emphasis>
can be used to modify the text.  Separate text into several paragraphs by appending &bsol;r to the last item in
a paragraph.  The whole text block is positioned at plot coordinates <emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>, which is
mapped to a point on the block specified by <emphasis remap='I'>justify</emphasis> (see <emphasis remap='B'>JUSTIFICATION</emphasis> for details).
The whole block is then shifted by the amounts <emphasis remap='I'>shift</emphasis>[].  The box will be plotted using the current
fill and outline settings.  The <emphasis remap='I'>offset</emphasis> array holds the horizontal and vertical distance gaps between text and the surrounding
text box in distance units.  Use <emphasis remap='I'>mode</emphasis> to indicate whether the box should be straight (PSL_RECT_STRAIGHT = 0), rounded (PSL_RECT_ROUNDED = 1),
convex (PSL_RECT_CONVEX = 2) or concave (PSL_RECT_CONCAVE = 3).
    </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plotparagraph</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>,
<emphasis remap='B'>long</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Typesets paragraphs of text using the specified <emphasis remap='I'>fontsize</emphasis> (in points).
Here, <emphasis remap='I'>text</emphasis> is an array of the text to be typeset, using the settings
initialized by <emphasis remap='B'>PSL_setparagraph</emphasis>.  The escape sequences described for <emphasis remap='B'>PSL_plottext</emphasis>
can be used to modify the text.  Separate text into several paragraphs by appending &bsol;r to the last item in
a paragraph.  The whole text block is positioned at plot coordinates <emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>, which is
mapped to a point on the block specified by <emphasis remap='I'>justify</emphasis> (see <emphasis remap='B'>JUSTIFICATION</emphasis> for details).
See <emphasis remap='B'>PSL_plotparagraphbox</emphasis> for laying down the surrounding text rectangle first.
    </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_plottextpath</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>n</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>node</emphasis>[],
<emphasis remap='B'>double</emphasis> <emphasis remap='I'>fontsize</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>m</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>angle</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>justify</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>offset</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Please text along a curved path.  This function is also called twice: First time we pass the text strings and locations
and <emphasis remap='I'>PostScript</emphasis> will compute
clip paths so that no features plotted after this call will be visible in areas where text will be plotted.
The second call actually plots the texts in the predetermined locations (NULL may be passed for all arrays for
the second call).  All labels will follow the path specified by the plot coordinates in the <emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis> arrays
(for plotting straight text with clipping, see <emphasis remap='B'>PSL_plottextclip</emphasis>).
The <emphasis remap='I'>node</emphasis> array contains the index numbers into the <emphasis remap='I'>x</emphasis> and <emphasis remap='I'>y</emphasis> arrays where each labels will be plotted; there are
<emphasis remap='I'>n</emphasis> such labels and node locations.  Each label has its own entry in the <emphasis remap='I'>angle</emphasis> array.  The <emphasis remap='I'>text</emphasis> is an
array of text pointers to the individual text items, which will all appear using the current font and scaled
to specified <emphasis remap='I'>fontsize</emphasis> (in points).  The <emphasis remap='I'>offset</emphasis> array holds the x and y distance gaps between text and the surrounding
text box in user units (the clip path is the combination of all these text boxes).  Use <emphasis remap='I'>justify</emphasis> to specify how the
text string relates to the coordinates (see BF(JUSTIFICATION) for details).  Finally, <emphasis remap='I'>mode</emphasis> is a bit pattern that
controls how the function does its work; pass <emphasis remap='I'>mode</emphasis> as the sum of the values you need:  0 = lay down clip path,
1 = place the text, 2 = turn off clipping, 4 = draw the <emphasis remap='I'>x-y</emphasis> line (useful for debugging), 8 = reuse the previous
parameters (so pass NULL as args), 16 = construct rounded text boxes [Default is rectangular], 32 = set the first time <emphasis remap='B'>PSL_plottextpath</emphasis> is
called (if you are placing text several times), 64 = set the last time <emphasis remap='B'>PSL_plottextpath</emphasis> is called,
128 = fill the text box (this requires you to first define the text box rgb color with <emphasis remap='B'>PSL_define_rgb</emphasis> by setting
a local <emphasis remap='I'>PostScript</emphasis> variable that must be called PSL_setboxrgb), and 256 = draw the text box outlines (this requires you to
first define the text box pen with <emphasis remap='B'>PSL_define_pen</emphasis> by setting a local <emphasis remap='I'>PostScript</emphasis> variable that must be called PSL_setboxpen).
For font color you must use <emphasis remap='B'>PSL_define_rgb</emphasis> and create a <emphasis remap='I'>PostScript</emphasis> variable called PSL_settxtrgb.  If not set we default
to black.
    </para></blockquote> <!-- remap='RE' -->
  </blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='clipping'><title>CLIPPING</title>
<para>Here are functions used to activate and deactivate clipping regions.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_beginclipping</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>x</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>y</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>n</emphasis>, <emphasis remap='B'>double</emphasis> <emphasis remap='I'>rgb</emphasis>[], <emphasis remap='B'>long</emphasis> <emphasis remap='I'>flag</emphasis>)</para>
  <blockquote remap='RS'>
<para>Sets up a user-definable clip path as a series on <emphasis remap='I'>n</emphasis> points with plot coordinates (<emphasis remap='I'>x</emphasis>, <emphasis remap='I'>y</emphasis>).
Plotting outside this polygon will be clipped
until <emphasis remap='B'>PSL_endclipping</emphasis> is called.  If <emphasis remap='I'>rgb</emphasis>[0] = -1 the inside of the path is left empty, otherwise it is
filled with the specified color.  <emphasis remap='I'>flag</emphasis> is used to create complex clip paths
consisting of several disconnected regions, and takes on values 0-3. <emphasis remap='I'>flag</emphasis> = PSL_PEN_MOVE_ABS (1)
means this is the first path in a multisegment clip path.  <emphasis remap='I'>flag</emphasis> = PSL_PEN_DRAW_ABS (2) means
this is the last segment.  Thus, for a single path, <emphasis remap='I'>flag</emphasis> = PSL_PEN_DRAW_AND_STROKE_ABS (3).
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_endclipping</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>long</emphasis> <emphasis remap='I'>mode</emphasis>)</para>
  <blockquote remap='RS'>
<para>Depending on the <emphasis remap='I'>mode</emphasis> it restores the clip path.  The <emphasis remap='I'>mode</emphasis> values
can be: -<emphasis remap='I'>n</emphasis> will restore <emphasis remap='I'>n</emphasis> levels of text-based clipping, <emphasis remap='I'>n</emphasis> will
restore <emphasis remap='I'>n</emphasis> levels of polygon clipping, PSL_ALL_CLIP_TXT will undo all
levels of text-based clipping, and PSL_ALL_CLIP_POL will undo all levels of
polygon-based clipping.
  </para></blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='miscellaneous_functions'><title>MISCELLANEOUS FUNCTIONS</title>
<para>Here are functions used to issue comments or to pass custom <emphasis remap='I'>PostScript</emphasis> commands directly to the output <emphasis remap='I'>PostScript</emphasis> file.
In C these functions are declared as macros and they can accept a variable
number of arguments.  However, from FORTRAN only a single text argument may be passed.</para>
<!-- .br -->

<para><emphasis remap='B'>long PSL_setcommand</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>)</para>
  <blockquote remap='RS'>
<para>Writes a raw <emphasis remap='I'>PostScript</emphasis> command to the <emphasis remap='I'>PostScript</emphasis> output file,
e.g. "1 setlinejoin\n".
  </para></blockquote> <!-- remap='RE'
.br -->

<para><emphasis remap='B'>long PSL_comment</emphasis> (<emphasis remap='B'>struct PSL_CTRL</emphasis> <emphasis remap='I'>*P</emphasis>, <emphasis remap='B'>char</emphasis> <emphasis remap='I'>*text</emphasis>)</para>
  <blockquote remap='RS'>
<para>Writes a comment (<emphasis remap='I'>text</emphasis>) to the <emphasis remap='I'>PostScript</emphasis> output file, e.g. "Start of graph 2\n".
The comment are prefixed with with %% .
  </para></blockquote> <!-- remap='RE' -->
</refsect1>

<refsect1 xml:id='authors'><title>AUTHORS</title>
<para>Paul Wessel, School of Ocean and Earth Science and Technology, http://www.soest.hawaii.edu.
<!-- .br -->
Remko Scharroo, Altimetrics, http://www.altimetrics.com.</para>
</refsect1>

<refsect1 xml:id='bugs'><title>BUGS</title>
<para>Caveat Emptor:  The authors are <emphasis remap='B'>not</emphasis> responsible for any disasters, suicide attempts, or ulcers
caused by correct <emphasis remap='B'>or</emphasis> incorrect use of <emphasis remap='B'>PSL</emphasis>.  If you find bugs, please report
them to the authors by electronic mail.  Be sure to provide enough detail so that we
can recreate the problem.</para>
</refsect1>

<refsect1 xml:id='references'><title>REFERENCES</title>
<para>Adobe Systems Inc., 1990, <emphasis remap='I'>PostScript</emphasis> language reference manual, 2nd edition,
Addison-Wesley, (ISBN 0-201-18127-4).</para>
</refsect1>
</refentry>

